{"ast":null,"code":"'use strict';\n\n// Expose.\nmodule.exports = List;\nList.Item = ListItem;\nvar ListPrototype = List.prototype;\nvar ListItemPrototype = ListItem.prototype;\nvar IterPrototype = Iter.prototype;\n\n/* istanbul ignore next */\nvar $iterator = typeof Symbol === 'undefined' ? undefined : Symbol.iterator;\nListPrototype.tail = ListPrototype.head = null;\nList.of = of;\nList.from = from;\nListPrototype.toArray = toArray;\nListPrototype.prepend = prepend;\nListPrototype.append = append;\n\n/* istanbul ignore else */\nif ($iterator !== undefined) {\n  ListPrototype[$iterator] = iterator;\n}\nListItemPrototype.next = ListItemPrototype.prev = ListItemPrototype.list = null;\nListItemPrototype.prepend = prependItem;\nListItemPrototype.append = appendItem;\nListItemPrototype.detach = detach;\nIterPrototype.next = next;\n\n// Constants.\nvar errorMessage = 'An argument without append, prepend, or detach methods was given to `List';\n\n// Creates a new List: A linked list is a bit like an Array, but knows nothing\n// about how many items are in it, and knows only about its first (`head`) and\n// last (`tail`) items.\n// Each item (e.g. `head`, `tail`, &c.) knows which item comes before or after\n// it (its more like the implementation of the DOM in JavaScript).\nfunction List( /* items... */\n) {\n  this.size = 0;\n  if (arguments.length !== 0) {\n    appendAll(this, arguments);\n  }\n}\n\n// Creates a new list from the arguments (each a list item) passed in.\nfunction appendAll(list, items) {\n  var length;\n  var index;\n  var item;\n  var iter;\n  if (!items) {\n    return list;\n  }\n  if ($iterator !== undefined && items[$iterator]) {\n    iter = items[$iterator]();\n    item = {};\n    while (!item.done) {\n      item = iter.next();\n      list.append(item && item.value);\n    }\n  } else {\n    length = items.length;\n    index = -1;\n    while (++index < length) {\n      list.append(items[index]);\n    }\n  }\n  return list;\n}\n\n// Creates a new list from the arguments (each a list item) passed in.\nfunction of( /* items... */\n) {\n  return appendAll(new this(), arguments);\n}\n\n// Creates a new list from the given array-like object (each a list item) passed\n// in.\nfunction from(items) {\n  return appendAll(new this(), items);\n}\n\n// Returns the list’s items as an array.\n// This does *not* detach the items.\nfunction toArray() {\n  var item = this.head;\n  var result = [];\n  while (item) {\n    result.push(item);\n    item = item.next;\n  }\n  return result;\n}\n\n// Prepends the given item to the list.\n// `item` will be the new first item (`head`).\nfunction prepend(item) {\n  var self = this;\n  var head = self.head;\n  if (!item) {\n    return false;\n  }\n  if (!item.append || !item.prepend || !item.detach) {\n    throw new Error(errorMessage + '#prepend`.');\n  }\n  if (head) {\n    return head.prepend(item);\n  }\n  item.detach();\n  item.list = self;\n  self.head = item;\n  self.size++;\n  return item;\n}\n\n// Appends the given item to the list.\n// `item` will be the new last item (`tail`) if the list had a first item, and\n// its first item (`head`) otherwise.\nfunction append(item) {\n  if (!item) {\n    return false;\n  }\n  if (!item.append || !item.prepend || !item.detach) {\n    throw new Error(errorMessage + '#append`.');\n  }\n  var self = this;\n  var head = self.head;\n  var tail = self.tail;\n\n  // If self has a last item, defer appending to the last items append method,\n  // and return the result.\n  if (tail) {\n    return tail.append(item);\n  }\n\n  // If self has a first item, defer appending to the first items append method,\n  // and return the result.\n  if (head) {\n    return head.append(item);\n  }\n\n  // …otherwise, there is no `tail` or `head` item yet.\n\n  item.detach();\n  item.list = self;\n  self.head = item;\n  self.size++;\n  return item;\n}\n\n// Creates an iterator from the list.\nfunction iterator() {\n  return new Iter(this.head);\n}\n\n// Creates a new ListItem:\n// An item is a bit like DOM node: It knows only about its \"parent\" (`list`),\n// the item before it (`prev`), and the item after it (`next`).\nfunction ListItem() {}\n\n// Detaches the item operated on from its parent list.\nfunction detach() {\n  var self = this;\n  var list = self.list;\n  var prev = self.prev;\n  var next = self.next;\n  if (!list) {\n    return self;\n  }\n\n  // If self is the last item in the parent list, link the lists last item to\n  // the previous item.\n  if (list.tail === self) {\n    list.tail = prev;\n  }\n\n  // If self is the first item in the parent list, link the lists first item to\n  // the next item.\n  if (list.head === self) {\n    list.head = next;\n  }\n\n  // If both the last and first items in the parent list are the same, remove\n  // the link to the last item.\n  if (list.tail === list.head) {\n    list.tail = null;\n  }\n\n  // If a previous item exists, link its next item to selfs next item.\n  if (prev) {\n    prev.next = next;\n  }\n\n  // If a next item exists, link its previous item to selfs previous item.\n  if (next) {\n    next.prev = prev;\n  }\n\n  // Remove links from self to both the next and previous items, and to the\n  // parent list.\n  self.prev = self.next = self.list = null;\n  list.size--;\n  return self;\n}\n\n// Prepends the given item *before* the item operated on.\nfunction prependItem(item) {\n  if (!item || !item.append || !item.prepend || !item.detach) {\n    throw new Error(errorMessage + 'Item#prepend`.');\n  }\n  var self = this;\n  var list = self.list;\n  var prev = self.prev;\n\n  // If self is detached, return false.\n  if (!list) {\n    return false;\n  }\n\n  // Detach the prependee.\n  item.detach();\n\n  // If self has a previous item...\n  if (prev) {\n    item.prev = prev;\n    prev.next = item;\n  }\n\n  // Connect the prependee.\n  item.next = self;\n  item.list = list;\n\n  // Set the previous item of self to the prependee.\n  self.prev = item;\n\n  // If self is the first item in the parent list, link the lists first item to\n  // the prependee.\n  if (self === list.head) {\n    list.head = item;\n  }\n\n  // If the the parent list has no last item, link the lists last item to self.\n  if (!list.tail) {\n    list.tail = self;\n  }\n  list.size++;\n  return item;\n}\n\n// Appends the given item *after* the item operated on.\nfunction appendItem(item) {\n  if (!item || !item.append || !item.prepend || !item.detach) {\n    throw new Error(errorMessage + 'Item#append`.');\n  }\n  var self = this;\n  var list = self.list;\n  var next = self.next;\n  if (!list) {\n    return false;\n  }\n\n  // Detach the appendee.\n  item.detach();\n\n  // If self has a next item…\n  if (next) {\n    item.next = next;\n    next.prev = item;\n  }\n\n  // Connect the appendee.\n  item.prev = self;\n  item.list = list;\n\n  // Set the next item of self to the appendee.\n  self.next = item;\n\n  // If the the parent list has no last item or if self is the parent lists last\n  // item, link the lists last item to the appendee.\n  if (self === list.tail || !list.tail) {\n    list.tail = item;\n  }\n  list.size++;\n  return item;\n}\n\n// Creates a new `Iter` for looping over the `LinkedList`.\nfunction Iter(item) {\n  this.item = item;\n}\n\n// Move the `Iter` to the next item.\nfunction next() {\n  var current = this.item;\n  this.value = current;\n  this.done = !current;\n  this.item = current ? current.next : undefined;\n  return this;\n}","map":{"version":3,"names":["module","exports","List","Item","ListItem","ListPrototype","prototype","ListItemPrototype","IterPrototype","Iter","$iterator","Symbol","undefined","iterator","tail","head","of","from","toArray","prepend","append","next","prev","list","prependItem","appendItem","detach","errorMessage","size","arguments","length","appendAll","items","index","item","iter","done","value","result","push","self","Error","current"],"sources":["C:/Users/bryan/Desktop/Projects/my-app/node_modules/linked-list/index.js"],"sourcesContent":["'use strict'\n\n// Expose.\nmodule.exports = List\n\nList.Item = ListItem\n\nvar ListPrototype = List.prototype\nvar ListItemPrototype = ListItem.prototype\nvar IterPrototype = Iter.prototype\n\n/* istanbul ignore next */\nvar $iterator = typeof Symbol === 'undefined' ? undefined : Symbol.iterator\n\nListPrototype.tail = ListPrototype.head = null\n\nList.of = of\nList.from = from\n\nListPrototype.toArray = toArray\nListPrototype.prepend = prepend\nListPrototype.append = append\n\n/* istanbul ignore else */\nif ($iterator !== undefined) {\n  ListPrototype[$iterator] = iterator\n}\n\nListItemPrototype.next = ListItemPrototype.prev = ListItemPrototype.list = null\n\nListItemPrototype.prepend = prependItem\nListItemPrototype.append = appendItem\nListItemPrototype.detach = detach\n\nIterPrototype.next = next\n\n// Constants.\nvar errorMessage =\n  'An argument without append, prepend, or detach methods was given to `List'\n\n// Creates a new List: A linked list is a bit like an Array, but knows nothing\n// about how many items are in it, and knows only about its first (`head`) and\n// last (`tail`) items.\n// Each item (e.g. `head`, `tail`, &c.) knows which item comes before or after\n// it (its more like the implementation of the DOM in JavaScript).\nfunction List(/* items... */) {\n  this.size = 0\n\n  if (arguments.length !== 0) {\n    appendAll(this, arguments)\n  }\n}\n\n// Creates a new list from the arguments (each a list item) passed in.\nfunction appendAll(list, items) {\n  var length\n  var index\n  var item\n  var iter\n\n  if (!items) {\n    return list\n  }\n\n  if ($iterator !== undefined && items[$iterator]) {\n    iter = items[$iterator]()\n    item = {}\n\n    while (!item.done) {\n      item = iter.next()\n      list.append(item && item.value)\n    }\n  } else {\n    length = items.length\n    index = -1\n\n    while (++index < length) {\n      list.append(items[index])\n    }\n  }\n\n  return list\n}\n\n// Creates a new list from the arguments (each a list item) passed in.\nfunction of(/* items... */) {\n  return appendAll(new this(), arguments)\n}\n\n// Creates a new list from the given array-like object (each a list item) passed\n// in.\nfunction from(items) {\n  return appendAll(new this(), items)\n}\n\n// Returns the list’s items as an array.\n// This does *not* detach the items.\nfunction toArray() {\n  var item = this.head\n  var result = []\n\n  while (item) {\n    result.push(item)\n    item = item.next\n  }\n\n  return result\n}\n\n// Prepends the given item to the list.\n// `item` will be the new first item (`head`).\nfunction prepend(item) {\n  var self = this\n  var head = self.head\n\n  if (!item) {\n    return false\n  }\n\n  if (!item.append || !item.prepend || !item.detach) {\n    throw new Error(errorMessage + '#prepend`.')\n  }\n\n  if (head) {\n    return head.prepend(item)\n  }\n\n  item.detach()\n\n  item.list = self\n  self.head = item\n  self.size++\n\n  return item\n}\n\n// Appends the given item to the list.\n// `item` will be the new last item (`tail`) if the list had a first item, and\n// its first item (`head`) otherwise.\nfunction append(item) {\n  if (!item) {\n    return false\n  }\n\n  if (!item.append || !item.prepend || !item.detach) {\n    throw new Error(errorMessage + '#append`.')\n  }\n\n  var self = this\n  var head = self.head\n  var tail = self.tail\n\n  // If self has a last item, defer appending to the last items append method,\n  // and return the result.\n  if (tail) {\n    return tail.append(item)\n  }\n\n  // If self has a first item, defer appending to the first items append method,\n  // and return the result.\n  if (head) {\n    return head.append(item)\n  }\n\n  // …otherwise, there is no `tail` or `head` item yet.\n\n  item.detach()\n\n  item.list = self\n  self.head = item\n  self.size++\n\n  return item\n}\n\n// Creates an iterator from the list.\nfunction iterator() {\n  return new Iter(this.head)\n}\n\n// Creates a new ListItem:\n// An item is a bit like DOM node: It knows only about its \"parent\" (`list`),\n// the item before it (`prev`), and the item after it (`next`).\nfunction ListItem() {}\n\n// Detaches the item operated on from its parent list.\nfunction detach() {\n  var self = this\n  var list = self.list\n  var prev = self.prev\n  var next = self.next\n\n  if (!list) {\n    return self\n  }\n\n  // If self is the last item in the parent list, link the lists last item to\n  // the previous item.\n  if (list.tail === self) {\n    list.tail = prev\n  }\n\n  // If self is the first item in the parent list, link the lists first item to\n  // the next item.\n  if (list.head === self) {\n    list.head = next\n  }\n\n  // If both the last and first items in the parent list are the same, remove\n  // the link to the last item.\n  if (list.tail === list.head) {\n    list.tail = null\n  }\n\n  // If a previous item exists, link its next item to selfs next item.\n  if (prev) {\n    prev.next = next\n  }\n\n  // If a next item exists, link its previous item to selfs previous item.\n  if (next) {\n    next.prev = prev\n  }\n\n  // Remove links from self to both the next and previous items, and to the\n  // parent list.\n  self.prev = self.next = self.list = null\n\n  list.size--\n\n  return self\n}\n\n// Prepends the given item *before* the item operated on.\nfunction prependItem(item) {\n  if (!item || !item.append || !item.prepend || !item.detach) {\n    throw new Error(errorMessage + 'Item#prepend`.')\n  }\n\n  var self = this\n  var list = self.list\n  var prev = self.prev\n\n  // If self is detached, return false.\n  if (!list) {\n    return false\n  }\n\n  // Detach the prependee.\n  item.detach()\n\n  // If self has a previous item...\n  if (prev) {\n    item.prev = prev\n    prev.next = item\n  }\n\n  // Connect the prependee.\n  item.next = self\n  item.list = list\n\n  // Set the previous item of self to the prependee.\n  self.prev = item\n\n  // If self is the first item in the parent list, link the lists first item to\n  // the prependee.\n  if (self === list.head) {\n    list.head = item\n  }\n\n  // If the the parent list has no last item, link the lists last item to self.\n  if (!list.tail) {\n    list.tail = self\n  }\n\n  list.size++\n\n  return item\n}\n\n// Appends the given item *after* the item operated on.\nfunction appendItem(item) {\n  if (!item || !item.append || !item.prepend || !item.detach) {\n    throw new Error(errorMessage + 'Item#append`.')\n  }\n\n  var self = this\n  var list = self.list\n  var next = self.next\n\n  if (!list) {\n    return false\n  }\n\n  // Detach the appendee.\n  item.detach()\n\n  // If self has a next item…\n  if (next) {\n    item.next = next\n    next.prev = item\n  }\n\n  // Connect the appendee.\n  item.prev = self\n  item.list = list\n\n  // Set the next item of self to the appendee.\n  self.next = item\n\n  // If the the parent list has no last item or if self is the parent lists last\n  // item, link the lists last item to the appendee.\n  if (self === list.tail || !list.tail) {\n    list.tail = item\n  }\n\n  list.size++\n\n  return item\n}\n\n// Creates a new `Iter` for looping over the `LinkedList`.\nfunction Iter(item) {\n  this.item = item\n}\n\n// Move the `Iter` to the next item.\nfunction next() {\n  var current = this.item\n  this.value = current\n  this.done = !current\n  this.item = current ? current.next : undefined\n  return this\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}