{"ast":null,"code":"import difference from 'lodash/difference';\nimport union from 'lodash/union';\nimport isPlainObject from 'lodash/isPlainObject';\nimport getSymbolObservable from './getSymbolObservable';\nexport const ActionTypes = {\n  PERFORM_ACTION: 'PERFORM_ACTION',\n  RESET: 'RESET',\n  ROLLBACK: 'ROLLBACK',\n  COMMIT: 'COMMIT',\n  SWEEP: 'SWEEP',\n  TOGGLE_ACTION: 'TOGGLE_ACTION',\n  SET_ACTIONS_ACTIVE: 'SET_ACTIONS_ACTIVE',\n  JUMP_TO_STATE: 'JUMP_TO_STATE',\n  JUMP_TO_ACTION: 'JUMP_TO_ACTION',\n  REORDER_ACTION: 'REORDER_ACTION',\n  IMPORT_STATE: 'IMPORT_STATE',\n  LOCK_CHANGES: 'LOCK_CHANGES',\n  PAUSE_RECORDING: 'PAUSE_RECORDING'\n};\nconst isChrome = typeof window === 'object' && (typeof window.chrome !== 'undefined' || typeof window.process !== 'undefined' && window.process.type === 'renderer');\nconst isChromeOrNode = isChrome || typeof process !== 'undefined' && process.release && process.release.name === 'node';\n/**\n * Action creators to change the History state.\n */\nexport const ActionCreators = {\n  performAction(action, trace, traceLimit,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  toExcludeFromTrace) {\n    if (!isPlainObject(action)) {\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n    }\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n    let stack;\n    if (trace) {\n      let extraFrames = 0;\n      if (typeof trace === 'function') {\n        stack = trace(action);\n      } else {\n        const error = Error();\n        let prevStackTraceLimit;\n        if (Error.captureStackTrace && isChromeOrNode) {\n          // avoid error-polyfill\n          if (traceLimit && Error.stackTraceLimit < traceLimit) {\n            prevStackTraceLimit = Error.stackTraceLimit;\n            Error.stackTraceLimit = traceLimit;\n          }\n          Error.captureStackTrace(error, toExcludeFromTrace);\n        } else {\n          extraFrames = 3;\n        }\n        stack = error.stack;\n        if (prevStackTraceLimit) Error.stackTraceLimit = prevStackTraceLimit;\n        if (extraFrames || typeof Error.stackTraceLimit !== 'number' || traceLimit && Error.stackTraceLimit > traceLimit) {\n          if (stack != null) {\n            const frames = stack.split('\\n');\n            if (traceLimit && frames.length > traceLimit) {\n              stack = frames.slice(0, traceLimit + extraFrames + (frames[0].startsWith('Error') ? 1 : 0)).join('\\n');\n            }\n          }\n        }\n      }\n    }\n    return {\n      type: ActionTypes.PERFORM_ACTION,\n      action,\n      timestamp: Date.now(),\n      stack\n    };\n  },\n  reset() {\n    return {\n      type: ActionTypes.RESET,\n      timestamp: Date.now()\n    };\n  },\n  rollback() {\n    return {\n      type: ActionTypes.ROLLBACK,\n      timestamp: Date.now()\n    };\n  },\n  commit() {\n    return {\n      type: ActionTypes.COMMIT,\n      timestamp: Date.now()\n    };\n  },\n  sweep() {\n    return {\n      type: ActionTypes.SWEEP\n    };\n  },\n  toggleAction(id) {\n    return {\n      type: ActionTypes.TOGGLE_ACTION,\n      id\n    };\n  },\n  setActionsActive(start, end) {\n    let active = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return {\n      type: ActionTypes.SET_ACTIONS_ACTIVE,\n      start,\n      end,\n      active\n    };\n  },\n  reorderAction(actionId, beforeActionId) {\n    return {\n      type: ActionTypes.REORDER_ACTION,\n      actionId,\n      beforeActionId\n    };\n  },\n  jumpToState(index) {\n    return {\n      type: ActionTypes.JUMP_TO_STATE,\n      index\n    };\n  },\n  jumpToAction(actionId) {\n    return {\n      type: ActionTypes.JUMP_TO_ACTION,\n      actionId\n    };\n  },\n  importState(nextLiftedState, noRecompute) {\n    return {\n      type: ActionTypes.IMPORT_STATE,\n      nextLiftedState,\n      noRecompute\n    };\n  },\n  lockChanges(status) {\n    return {\n      type: ActionTypes.LOCK_CHANGES,\n      status\n    };\n  },\n  pauseRecording(status) {\n    return {\n      type: ActionTypes.PAUSE_RECORDING,\n      status\n    };\n  }\n};\nexport const INIT_ACTION = {\n  type: '@@INIT'\n};\n\n/**\n * Computes the next entry with exceptions catching.\n */\nfunction computeWithTryCatch(reducer, action, state) {\n  let nextState = state;\n  let nextError;\n  try {\n    nextState = reducer(state, action);\n  } catch (err) {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    nextError = err.toString();\n    if (isChrome) {\n      // In Chrome, rethrowing provides better source map support\n      setTimeout(() => {\n        throw err;\n      });\n    } else {\n      console.error(err); // eslint-disable-line no-console\n    }\n  }\n\n  return {\n    state: nextState,\n    error: nextError\n  };\n}\n\n/**\n * Computes the next entry in the log by applying an action.\n */\nfunction computeNextEntry(reducer, action, state, shouldCatchErrors) {\n  if (!shouldCatchErrors) {\n    return {\n      state: reducer(state, action)\n    };\n  }\n  return computeWithTryCatch(reducer, action, state);\n}\n\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n */\nfunction recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, shouldCatchErrors) {\n  // Optimization: exit early and return the same reference\n  // if we know nothing could have changed.\n  if (!computedStates || minInvalidatedStateIndex === -1 || minInvalidatedStateIndex >= computedStates.length && computedStates.length === stagedActionIds.length) {\n    return computedStates;\n  }\n  const nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n  for (let i = minInvalidatedStateIndex; i < stagedActionIds.length; i++) {\n    const actionId = stagedActionIds[i];\n    const action = actionsById[actionId].action;\n    const previousEntry = nextComputedStates[i - 1];\n    const previousState = previousEntry ? previousEntry.state : committedState;\n    const shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n    let entry;\n    if (shouldSkip) {\n      entry = previousEntry;\n    } else {\n      if (shouldCatchErrors && previousEntry && previousEntry.error) {\n        entry = {\n          state: previousState,\n          error: 'Interrupted by an error up the chain'\n        };\n      } else {\n        entry = computeNextEntry(reducer, action, previousState, shouldCatchErrors);\n      }\n    }\n    nextComputedStates.push(entry);\n  }\n  return nextComputedStates;\n}\n\n/**\n * Lifts an app's action into an action on the lifted store.\n */\nfunction liftAction(action, trace, traceLimit,\n// eslint-disable-next-line @typescript-eslint/ban-types\ntoExcludeFromTrace) {\n  return ActionCreators.performAction(action, trace, traceLimit, toExcludeFromTrace);\n}\nfunction isArray(nextLiftedState) {\n  return Array.isArray(nextLiftedState);\n}\n/**\n * Creates a history state reducer from an app's reducer.\n */\nfunction liftReducerWith(reducer, initialCommittedState, monitorReducer, options) {\n  const initialLiftedState = {\n    monitorState: monitorReducer(undefined, {}),\n    nextActionId: 1,\n    actionsById: {\n      0: liftAction(INIT_ACTION)\n    },\n    stagedActionIds: [0],\n    skippedActionIds: [],\n    committedState: initialCommittedState,\n    currentStateIndex: 0,\n    computedStates: [],\n    isLocked: options.shouldStartLocked === true,\n    isPaused: options.shouldRecordChanges === false\n  };\n\n  /**\n   * Manages how the history actions modify the history state.\n   */\n  return (liftedState, liftedAction) => {\n    let {\n      monitorState,\n      actionsById,\n      nextActionId,\n      stagedActionIds,\n      skippedActionIds,\n      committedState,\n      currentStateIndex,\n      computedStates,\n      isLocked,\n      isPaused\n    } = liftedState || initialLiftedState;\n    if (!liftedState) {\n      // Prevent mutating initialLiftedState\n      actionsById = {\n        ...actionsById\n      };\n    }\n    function commitExcessActions(n) {\n      // Auto-commits n-number of excess actions.\n      let excess = n;\n      let idsToDelete = stagedActionIds.slice(1, excess + 1);\n      for (let i = 0; i < idsToDelete.length; i++) {\n        if (computedStates[i + 1].error) {\n          // Stop if error is found. Commit actions up to error.\n          excess = i;\n          idsToDelete = stagedActionIds.slice(1, excess + 1);\n          break;\n        } else {\n          delete actionsById[idsToDelete[i]];\n        }\n      }\n      skippedActionIds = skippedActionIds.filter(id => idsToDelete.indexOf(id) === -1);\n      stagedActionIds = [0, ...stagedActionIds.slice(excess + 1)];\n      committedState = computedStates[excess].state;\n      computedStates = computedStates.slice(excess);\n      currentStateIndex = currentStateIndex > excess ? currentStateIndex - excess : 0;\n    }\n    function computePausedAction(shouldInit) {\n      let computedState;\n      if (shouldInit) {\n        computedState = computedStates[currentStateIndex];\n        monitorState = monitorReducer(monitorState, liftedAction);\n      } else {\n        computedState = computeNextEntry(reducer, liftedAction.action, computedStates[currentStateIndex].state, false);\n      }\n      if (!options.pauseActionType || nextActionId === 1) {\n        return {\n          monitorState,\n          actionsById: {\n            0: liftAction(INIT_ACTION)\n          },\n          nextActionId: 1,\n          stagedActionIds: [0],\n          skippedActionIds: [],\n          committedState: computedState.state,\n          currentStateIndex: 0,\n          computedStates: [computedState],\n          isLocked,\n          isPaused: true\n        };\n      }\n      if (shouldInit) {\n        if (currentStateIndex === stagedActionIds.length - 1) {\n          currentStateIndex++;\n        }\n        stagedActionIds = [...stagedActionIds, nextActionId];\n        nextActionId++;\n      }\n      return {\n        monitorState,\n        actionsById: {\n          ...actionsById,\n          [nextActionId - 1]: liftAction({\n            type: options.pauseActionType\n          })\n        },\n        nextActionId,\n        stagedActionIds,\n        skippedActionIds,\n        committedState,\n        currentStateIndex,\n        computedStates: [...computedStates.slice(0, stagedActionIds.length - 1), computedState],\n        isLocked,\n        isPaused: true\n      };\n    }\n\n    // By default, aggressively recompute every state whatever happens.\n    // This has O(n) performance, so we'll override this to a sensible\n    // value whenever we feel like we don't have to recompute the states.\n    let minInvalidatedStateIndex = 0;\n\n    // maxAge number can be changed dynamically\n    let maxAge = options.maxAge;\n    if (typeof maxAge === 'function') maxAge = maxAge(liftedAction, liftedState);\n    if (/^@@redux\\/(INIT|REPLACE)/.test(liftedAction.type)) {\n      if (options.shouldHotReload === false) {\n        actionsById = {\n          0: liftAction(INIT_ACTION)\n        };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        committedState = computedStates.length === 0 ? initialCommittedState : computedStates[currentStateIndex].state;\n        currentStateIndex = 0;\n        computedStates = [];\n      }\n\n      // Recompute states on hot reload and init.\n      minInvalidatedStateIndex = 0;\n      if (maxAge && stagedActionIds.length > maxAge) {\n        // States must be recomputed before committing excess.\n        computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, options.shouldCatchErrors);\n        commitExcessActions(stagedActionIds.length - maxAge);\n\n        // Avoid double computation.\n        minInvalidatedStateIndex = Infinity;\n      }\n    } else {\n      switch (liftedAction.type) {\n        case ActionTypes.PERFORM_ACTION:\n          {\n            if (isLocked) return liftedState || initialLiftedState;\n            if (isPaused) return computePausedAction();\n\n            // Auto-commit as new actions come in.\n            if (maxAge && stagedActionIds.length >= maxAge) {\n              commitExcessActions(stagedActionIds.length - maxAge + 1);\n            }\n            if (currentStateIndex === stagedActionIds.length - 1) {\n              currentStateIndex++;\n            }\n            const actionId = nextActionId++;\n            // Mutation! This is the hottest path, and we optimize on purpose.\n            // It is safe because we set a new key in a cache dictionary.\n            actionsById[actionId] = liftedAction;\n            stagedActionIds = [...stagedActionIds, actionId];\n            // Optimization: we know that only the new action needs computing.\n            minInvalidatedStateIndex = stagedActionIds.length - 1;\n            break;\n          }\n        case ActionTypes.RESET:\n          {\n            // Get back to the state the store was created with.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = initialCommittedState;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n        case ActionTypes.COMMIT:\n          {\n            // Consider the last committed state the new starting point.\n            // Squash any staged actions into a single committed state.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = computedStates[currentStateIndex].state;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n        case ActionTypes.ROLLBACK:\n          {\n            // Forget about any staged actions.\n            // Start again from the last committed state.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n        case ActionTypes.TOGGLE_ACTION:\n          {\n            // Toggle whether an action with given ID is skipped.\n            // Being skipped means it is a no-op during the computation.\n            const {\n              id: actionId\n            } = liftedAction;\n            const index = skippedActionIds.indexOf(actionId);\n            if (index === -1) {\n              skippedActionIds = [actionId, ...skippedActionIds];\n            } else {\n              skippedActionIds = skippedActionIds.filter(id => id !== actionId);\n            }\n            // Optimization: we know history before this action hasn't changed\n            minInvalidatedStateIndex = stagedActionIds.indexOf(actionId);\n            break;\n          }\n        case ActionTypes.SET_ACTIONS_ACTIVE:\n          {\n            // Toggle whether an action with given ID is skipped.\n            // Being skipped means it is a no-op during the computation.\n            const {\n              start,\n              end,\n              active\n            } = liftedAction;\n            const actionIds = [];\n            for (let i = start; i < end; i++) actionIds.push(i);\n            if (active) {\n              skippedActionIds = difference(skippedActionIds, actionIds);\n            } else {\n              skippedActionIds = union(skippedActionIds, actionIds);\n            }\n\n            // Optimization: we know history before this action hasn't changed\n            minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n            break;\n          }\n        case ActionTypes.JUMP_TO_STATE:\n          {\n            // Without recomputing anything, move the pointer that tell us\n            // which state is considered the current one. Useful for sliders.\n            currentStateIndex = liftedAction.index;\n            // Optimization: we know the history has not changed.\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n        case ActionTypes.JUMP_TO_ACTION:\n          {\n            // Jumps to a corresponding state to a specific action.\n            // Useful when filtering actions.\n            const index = stagedActionIds.indexOf(liftedAction.actionId);\n            if (index !== -1) currentStateIndex = index;\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n        case ActionTypes.SWEEP:\n          {\n            // Forget any actions that are currently being skipped.\n            stagedActionIds = difference(stagedActionIds, skippedActionIds);\n            skippedActionIds = [];\n            currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);\n            break;\n          }\n        case ActionTypes.REORDER_ACTION:\n          {\n            // Recompute actions in a new order.\n            const actionId = liftedAction.actionId;\n            const idx = stagedActionIds.indexOf(actionId);\n            // do nothing in case the action is already removed or trying to move the first action\n            if (idx < 1) break;\n            const beforeActionId = liftedAction.beforeActionId;\n            let newIdx = stagedActionIds.indexOf(beforeActionId);\n            if (newIdx < 1) {\n              // move to the beginning or to the end\n              const count = stagedActionIds.length;\n              newIdx = beforeActionId > stagedActionIds[count - 1] ? count : 1;\n            }\n            const diff = idx - newIdx;\n            if (diff > 0) {\n              // move left\n              stagedActionIds = [...stagedActionIds.slice(0, newIdx), actionId, ...stagedActionIds.slice(newIdx, idx), ...stagedActionIds.slice(idx + 1)];\n              minInvalidatedStateIndex = newIdx;\n            } else if (diff < 0) {\n              // move right\n              stagedActionIds = [...stagedActionIds.slice(0, idx), ...stagedActionIds.slice(idx + 1, newIdx), actionId, ...stagedActionIds.slice(newIdx)];\n              minInvalidatedStateIndex = idx;\n            }\n            break;\n          }\n        case ActionTypes.IMPORT_STATE:\n          {\n            if (isArray(liftedAction.nextLiftedState)) {\n              // recompute array of actions\n              actionsById = {\n                0: liftAction(INIT_ACTION)\n              };\n              nextActionId = 1;\n              stagedActionIds = [0];\n              skippedActionIds = [];\n              currentStateIndex = liftedAction.nextLiftedState.length;\n              computedStates = [];\n              committedState = liftedAction.preloadedState;\n              minInvalidatedStateIndex = 0;\n              // iterate through actions\n              liftedAction.nextLiftedState.forEach(action => {\n                actionsById[nextActionId] = liftAction(action, options.trace || options.shouldIncludeCallstack);\n                stagedActionIds.push(nextActionId);\n                nextActionId++;\n              });\n            } else {\n              // Completely replace everything.\n              ({\n                monitorState,\n                actionsById,\n                nextActionId,\n                stagedActionIds,\n                skippedActionIds,\n                committedState,\n                currentStateIndex,\n                computedStates\n              } = liftedAction.nextLiftedState);\n              if (liftedAction.noRecompute) {\n                minInvalidatedStateIndex = Infinity;\n              }\n            }\n            break;\n          }\n        case ActionTypes.LOCK_CHANGES:\n          {\n            isLocked = liftedAction.status;\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n        case ActionTypes.PAUSE_RECORDING:\n          {\n            isPaused = liftedAction.status;\n            if (isPaused) {\n              return computePausedAction(true);\n            }\n            // Commit when unpausing\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = computedStates[currentStateIndex].state;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n        default:\n          {\n            // If the action is not recognized, it's a monitor action.\n            // Optimization: a monitor action can't change history.\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n      }\n    }\n    computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, options.shouldCatchErrors);\n    monitorState = monitorReducer(monitorState, liftedAction);\n    return {\n      monitorState,\n      actionsById,\n      nextActionId,\n      stagedActionIds,\n      skippedActionIds,\n      committedState,\n      currentStateIndex,\n      computedStates,\n      isLocked,\n      isPaused\n    };\n  };\n}\n\n/**\n * Provides an app's view into the state of the lifted store.\n */\nfunction unliftState(liftedState) {\n  const {\n    computedStates,\n    currentStateIndex\n  } = liftedState;\n  const {\n    state\n  } = computedStates[currentStateIndex];\n  return state;\n}\n/**\n * Provides an app's view into the lifted store.\n */\nfunction unliftStore(liftedStore, liftReducer, options) {\n  let lastDefinedState;\n  const trace = options.trace || options.shouldIncludeCallstack;\n  const traceLimit = options.traceLimit || 10;\n  function getState() {\n    const state = unliftState(liftedStore.getState());\n    if (state !== undefined) {\n      lastDefinedState = state;\n    }\n    return lastDefinedState;\n  }\n  function dispatch(action) {\n    liftedStore.dispatch(liftAction(action, trace, traceLimit, dispatch));\n    return action;\n  }\n  const $$observable = getSymbolObservable();\n  if (!($$observable in liftedStore)) {\n    console.warn('Symbol.observable as defined by Redux and Redux DevTools do not match. This could cause your app to behave differently if the DevTools are not loaded. Consider polyfilling Symbol.observable before Redux is imported or avoid polyfilling Symbol.observable altogether.');\n  }\n  return {\n    liftedStore,\n    dispatch,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    subscribe: liftedStore.subscribe,\n    getState,\n    replaceReducer(nextReducer) {\n      liftedStore.replaceReducer(liftReducer(nextReducer));\n    },\n    [$$observable]() {\n      return {\n        subscribe(observer) {\n          if (typeof observer !== 'object') {\n            throw new TypeError('Expected the observer to be an object.');\n          }\n          function observeState() {\n            if (observer.next) {\n              observer.next(getState());\n            }\n          }\n          observeState();\n          const unsubscribe = liftedStore.subscribe(observeState);\n          return {\n            unsubscribe\n          };\n        },\n        [$$observable]() {\n          return this;\n        }\n      };\n    }\n  };\n}\n/**\n * Redux instrumentation store enhancer.\n */\nexport function instrument() {\n  let monitorReducer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => null;\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof options.maxAge === 'number' && options.maxAge < 2) {\n    throw new Error('DevTools.instrument({ maxAge }) option, if specified, ' + 'may not be less than 2.');\n  }\n  return createStore => (reducer, initialState) => {\n    function liftReducer(r) {\n      if (typeof r !== 'function') {\n        if (r && typeof r.default === 'function') {\n          throw new Error('Expected the reducer to be a function. ' + 'Instead got an object with a \"default\" field. ' + 'Did you pass a module instead of the default export? ' + 'Try passing require(...).default instead.');\n        }\n        throw new Error('Expected the reducer to be a function.');\n      }\n      return liftReducerWith(r, initialState, monitorReducer, options);\n    }\n    const liftedStore = createStore(liftReducer(reducer));\n    if (liftedStore.liftedStore) {\n      throw new Error('DevTools instrumentation should not be applied more than once. ' + 'Check your store configuration.');\n    }\n    return unliftStore(liftedStore, liftReducer, options);\n  };\n}","map":{"version":3,"names":["difference","union","isPlainObject","getSymbolObservable","ActionTypes","PERFORM_ACTION","RESET","ROLLBACK","COMMIT","SWEEP","TOGGLE_ACTION","SET_ACTIONS_ACTIVE","JUMP_TO_STATE","JUMP_TO_ACTION","REORDER_ACTION","IMPORT_STATE","LOCK_CHANGES","PAUSE_RECORDING","isChrome","window","chrome","process","type","isChromeOrNode","release","name","ActionCreators","performAction","action","trace","traceLimit","toExcludeFromTrace","Error","stack","extraFrames","error","prevStackTraceLimit","captureStackTrace","stackTraceLimit","frames","split","length","slice","startsWith","join","timestamp","Date","now","reset","rollback","commit","sweep","toggleAction","id","setActionsActive","start","end","active","arguments","undefined","reorderAction","actionId","beforeActionId","jumpToState","index","jumpToAction","importState","nextLiftedState","noRecompute","lockChanges","status","pauseRecording","INIT_ACTION","computeWithTryCatch","reducer","state","nextState","nextError","err","toString","setTimeout","console","computeNextEntry","shouldCatchErrors","recomputeStates","computedStates","minInvalidatedStateIndex","committedState","actionsById","stagedActionIds","skippedActionIds","nextComputedStates","i","previousEntry","previousState","shouldSkip","indexOf","entry","push","liftAction","isArray","Array","liftReducerWith","initialCommittedState","monitorReducer","options","initialLiftedState","monitorState","nextActionId","currentStateIndex","isLocked","shouldStartLocked","isPaused","shouldRecordChanges","liftedState","liftedAction","commitExcessActions","n","excess","idsToDelete","filter","computePausedAction","shouldInit","computedState","pauseActionType","maxAge","test","shouldHotReload","Infinity","actionIds","Math","min","idx","newIdx","count","diff","preloadedState","forEach","shouldIncludeCallstack","unliftState","unliftStore","liftedStore","liftReducer","lastDefinedState","getState","dispatch","$$observable","warn","subscribe","replaceReducer","nextReducer","observer","TypeError","observeState","next","unsubscribe","instrument","createStore","initialState","r","default"],"sources":["C:/Users/bryan/Desktop/Projects/my-app/node_modules/@redux-devtools/instrument/lib/esm/instrument.js"],"sourcesContent":["import difference from 'lodash/difference';\nimport union from 'lodash/union';\nimport isPlainObject from 'lodash/isPlainObject';\nimport getSymbolObservable from './getSymbolObservable';\nexport const ActionTypes = {\n  PERFORM_ACTION: 'PERFORM_ACTION',\n  RESET: 'RESET',\n  ROLLBACK: 'ROLLBACK',\n  COMMIT: 'COMMIT',\n  SWEEP: 'SWEEP',\n  TOGGLE_ACTION: 'TOGGLE_ACTION',\n  SET_ACTIONS_ACTIVE: 'SET_ACTIONS_ACTIVE',\n  JUMP_TO_STATE: 'JUMP_TO_STATE',\n  JUMP_TO_ACTION: 'JUMP_TO_ACTION',\n  REORDER_ACTION: 'REORDER_ACTION',\n  IMPORT_STATE: 'IMPORT_STATE',\n  LOCK_CHANGES: 'LOCK_CHANGES',\n  PAUSE_RECORDING: 'PAUSE_RECORDING'\n};\nconst isChrome = typeof window === 'object' && (typeof window.chrome !== 'undefined' || typeof window.process !== 'undefined' && window.process.type === 'renderer');\nconst isChromeOrNode = isChrome || typeof process !== 'undefined' && process.release && process.release.name === 'node';\n/**\n * Action creators to change the History state.\n */\nexport const ActionCreators = {\n  performAction(action, trace, traceLimit,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  toExcludeFromTrace) {\n    if (!isPlainObject(action)) {\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n    }\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n    let stack;\n    if (trace) {\n      let extraFrames = 0;\n      if (typeof trace === 'function') {\n        stack = trace(action);\n      } else {\n        const error = Error();\n        let prevStackTraceLimit;\n        if (Error.captureStackTrace && isChromeOrNode) {\n          // avoid error-polyfill\n          if (traceLimit && Error.stackTraceLimit < traceLimit) {\n            prevStackTraceLimit = Error.stackTraceLimit;\n            Error.stackTraceLimit = traceLimit;\n          }\n          Error.captureStackTrace(error, toExcludeFromTrace);\n        } else {\n          extraFrames = 3;\n        }\n        stack = error.stack;\n        if (prevStackTraceLimit) Error.stackTraceLimit = prevStackTraceLimit;\n        if (extraFrames || typeof Error.stackTraceLimit !== 'number' || traceLimit && Error.stackTraceLimit > traceLimit) {\n          if (stack != null) {\n            const frames = stack.split('\\n');\n            if (traceLimit && frames.length > traceLimit) {\n              stack = frames.slice(0, traceLimit + extraFrames + (frames[0].startsWith('Error') ? 1 : 0)).join('\\n');\n            }\n          }\n        }\n      }\n    }\n    return {\n      type: ActionTypes.PERFORM_ACTION,\n      action,\n      timestamp: Date.now(),\n      stack\n    };\n  },\n  reset() {\n    return {\n      type: ActionTypes.RESET,\n      timestamp: Date.now()\n    };\n  },\n  rollback() {\n    return {\n      type: ActionTypes.ROLLBACK,\n      timestamp: Date.now()\n    };\n  },\n  commit() {\n    return {\n      type: ActionTypes.COMMIT,\n      timestamp: Date.now()\n    };\n  },\n  sweep() {\n    return {\n      type: ActionTypes.SWEEP\n    };\n  },\n  toggleAction(id) {\n    return {\n      type: ActionTypes.TOGGLE_ACTION,\n      id\n    };\n  },\n  setActionsActive(start, end) {\n    let active = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return {\n      type: ActionTypes.SET_ACTIONS_ACTIVE,\n      start,\n      end,\n      active\n    };\n  },\n  reorderAction(actionId, beforeActionId) {\n    return {\n      type: ActionTypes.REORDER_ACTION,\n      actionId,\n      beforeActionId\n    };\n  },\n  jumpToState(index) {\n    return {\n      type: ActionTypes.JUMP_TO_STATE,\n      index\n    };\n  },\n  jumpToAction(actionId) {\n    return {\n      type: ActionTypes.JUMP_TO_ACTION,\n      actionId\n    };\n  },\n  importState(nextLiftedState, noRecompute) {\n    return {\n      type: ActionTypes.IMPORT_STATE,\n      nextLiftedState,\n      noRecompute\n    };\n  },\n  lockChanges(status) {\n    return {\n      type: ActionTypes.LOCK_CHANGES,\n      status\n    };\n  },\n  pauseRecording(status) {\n    return {\n      type: ActionTypes.PAUSE_RECORDING,\n      status\n    };\n  }\n};\nexport const INIT_ACTION = {\n  type: '@@INIT'\n};\n\n/**\n * Computes the next entry with exceptions catching.\n */\nfunction computeWithTryCatch(reducer, action, state) {\n  let nextState = state;\n  let nextError;\n  try {\n    nextState = reducer(state, action);\n  } catch (err) {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    nextError = err.toString();\n    if (isChrome) {\n      // In Chrome, rethrowing provides better source map support\n      setTimeout(() => {\n        throw err;\n      });\n    } else {\n      console.error(err); // eslint-disable-line no-console\n    }\n  }\n\n  return {\n    state: nextState,\n    error: nextError\n  };\n}\n\n/**\n * Computes the next entry in the log by applying an action.\n */\nfunction computeNextEntry(reducer, action, state, shouldCatchErrors) {\n  if (!shouldCatchErrors) {\n    return {\n      state: reducer(state, action)\n    };\n  }\n  return computeWithTryCatch(reducer, action, state);\n}\n\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n */\nfunction recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, shouldCatchErrors) {\n  // Optimization: exit early and return the same reference\n  // if we know nothing could have changed.\n  if (!computedStates || minInvalidatedStateIndex === -1 || minInvalidatedStateIndex >= computedStates.length && computedStates.length === stagedActionIds.length) {\n    return computedStates;\n  }\n  const nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n  for (let i = minInvalidatedStateIndex; i < stagedActionIds.length; i++) {\n    const actionId = stagedActionIds[i];\n    const action = actionsById[actionId].action;\n    const previousEntry = nextComputedStates[i - 1];\n    const previousState = previousEntry ? previousEntry.state : committedState;\n    const shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n    let entry;\n    if (shouldSkip) {\n      entry = previousEntry;\n    } else {\n      if (shouldCatchErrors && previousEntry && previousEntry.error) {\n        entry = {\n          state: previousState,\n          error: 'Interrupted by an error up the chain'\n        };\n      } else {\n        entry = computeNextEntry(reducer, action, previousState, shouldCatchErrors);\n      }\n    }\n    nextComputedStates.push(entry);\n  }\n  return nextComputedStates;\n}\n\n/**\n * Lifts an app's action into an action on the lifted store.\n */\nfunction liftAction(action, trace, traceLimit,\n// eslint-disable-next-line @typescript-eslint/ban-types\ntoExcludeFromTrace) {\n  return ActionCreators.performAction(action, trace, traceLimit, toExcludeFromTrace);\n}\nfunction isArray(nextLiftedState) {\n  return Array.isArray(nextLiftedState);\n}\n/**\n * Creates a history state reducer from an app's reducer.\n */\nfunction liftReducerWith(reducer, initialCommittedState, monitorReducer, options) {\n  const initialLiftedState = {\n    monitorState: monitorReducer(undefined, {}),\n    nextActionId: 1,\n    actionsById: {\n      0: liftAction(INIT_ACTION)\n    },\n    stagedActionIds: [0],\n    skippedActionIds: [],\n    committedState: initialCommittedState,\n    currentStateIndex: 0,\n    computedStates: [],\n    isLocked: options.shouldStartLocked === true,\n    isPaused: options.shouldRecordChanges === false\n  };\n\n  /**\n   * Manages how the history actions modify the history state.\n   */\n  return (liftedState, liftedAction) => {\n    let {\n      monitorState,\n      actionsById,\n      nextActionId,\n      stagedActionIds,\n      skippedActionIds,\n      committedState,\n      currentStateIndex,\n      computedStates,\n      isLocked,\n      isPaused\n    } = liftedState || initialLiftedState;\n    if (!liftedState) {\n      // Prevent mutating initialLiftedState\n      actionsById = {\n        ...actionsById\n      };\n    }\n    function commitExcessActions(n) {\n      // Auto-commits n-number of excess actions.\n      let excess = n;\n      let idsToDelete = stagedActionIds.slice(1, excess + 1);\n      for (let i = 0; i < idsToDelete.length; i++) {\n        if (computedStates[i + 1].error) {\n          // Stop if error is found. Commit actions up to error.\n          excess = i;\n          idsToDelete = stagedActionIds.slice(1, excess + 1);\n          break;\n        } else {\n          delete actionsById[idsToDelete[i]];\n        }\n      }\n      skippedActionIds = skippedActionIds.filter(id => idsToDelete.indexOf(id) === -1);\n      stagedActionIds = [0, ...stagedActionIds.slice(excess + 1)];\n      committedState = computedStates[excess].state;\n      computedStates = computedStates.slice(excess);\n      currentStateIndex = currentStateIndex > excess ? currentStateIndex - excess : 0;\n    }\n    function computePausedAction(shouldInit) {\n      let computedState;\n      if (shouldInit) {\n        computedState = computedStates[currentStateIndex];\n        monitorState = monitorReducer(monitorState, liftedAction);\n      } else {\n        computedState = computeNextEntry(reducer, liftedAction.action, computedStates[currentStateIndex].state, false);\n      }\n      if (!options.pauseActionType || nextActionId === 1) {\n        return {\n          monitorState,\n          actionsById: {\n            0: liftAction(INIT_ACTION)\n          },\n          nextActionId: 1,\n          stagedActionIds: [0],\n          skippedActionIds: [],\n          committedState: computedState.state,\n          currentStateIndex: 0,\n          computedStates: [computedState],\n          isLocked,\n          isPaused: true\n        };\n      }\n      if (shouldInit) {\n        if (currentStateIndex === stagedActionIds.length - 1) {\n          currentStateIndex++;\n        }\n        stagedActionIds = [...stagedActionIds, nextActionId];\n        nextActionId++;\n      }\n      return {\n        monitorState,\n        actionsById: {\n          ...actionsById,\n          [nextActionId - 1]: liftAction({\n            type: options.pauseActionType\n          })\n        },\n        nextActionId,\n        stagedActionIds,\n        skippedActionIds,\n        committedState,\n        currentStateIndex,\n        computedStates: [...computedStates.slice(0, stagedActionIds.length - 1), computedState],\n        isLocked,\n        isPaused: true\n      };\n    }\n\n    // By default, aggressively recompute every state whatever happens.\n    // This has O(n) performance, so we'll override this to a sensible\n    // value whenever we feel like we don't have to recompute the states.\n    let minInvalidatedStateIndex = 0;\n\n    // maxAge number can be changed dynamically\n    let maxAge = options.maxAge;\n    if (typeof maxAge === 'function') maxAge = maxAge(liftedAction, liftedState);\n    if (/^@@redux\\/(INIT|REPLACE)/.test(liftedAction.type)) {\n      if (options.shouldHotReload === false) {\n        actionsById = {\n          0: liftAction(INIT_ACTION)\n        };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        committedState = computedStates.length === 0 ? initialCommittedState : computedStates[currentStateIndex].state;\n        currentStateIndex = 0;\n        computedStates = [];\n      }\n\n      // Recompute states on hot reload and init.\n      minInvalidatedStateIndex = 0;\n      if (maxAge && stagedActionIds.length > maxAge) {\n        // States must be recomputed before committing excess.\n        computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, options.shouldCatchErrors);\n        commitExcessActions(stagedActionIds.length - maxAge);\n\n        // Avoid double computation.\n        minInvalidatedStateIndex = Infinity;\n      }\n    } else {\n      switch (liftedAction.type) {\n        case ActionTypes.PERFORM_ACTION:\n          {\n            if (isLocked) return liftedState || initialLiftedState;\n            if (isPaused) return computePausedAction();\n\n            // Auto-commit as new actions come in.\n            if (maxAge && stagedActionIds.length >= maxAge) {\n              commitExcessActions(stagedActionIds.length - maxAge + 1);\n            }\n            if (currentStateIndex === stagedActionIds.length - 1) {\n              currentStateIndex++;\n            }\n            const actionId = nextActionId++;\n            // Mutation! This is the hottest path, and we optimize on purpose.\n            // It is safe because we set a new key in a cache dictionary.\n            actionsById[actionId] = liftedAction;\n            stagedActionIds = [...stagedActionIds, actionId];\n            // Optimization: we know that only the new action needs computing.\n            minInvalidatedStateIndex = stagedActionIds.length - 1;\n            break;\n          }\n        case ActionTypes.RESET:\n          {\n            // Get back to the state the store was created with.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = initialCommittedState;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n        case ActionTypes.COMMIT:\n          {\n            // Consider the last committed state the new starting point.\n            // Squash any staged actions into a single committed state.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = computedStates[currentStateIndex].state;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n        case ActionTypes.ROLLBACK:\n          {\n            // Forget about any staged actions.\n            // Start again from the last committed state.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n        case ActionTypes.TOGGLE_ACTION:\n          {\n            // Toggle whether an action with given ID is skipped.\n            // Being skipped means it is a no-op during the computation.\n            const {\n              id: actionId\n            } = liftedAction;\n            const index = skippedActionIds.indexOf(actionId);\n            if (index === -1) {\n              skippedActionIds = [actionId, ...skippedActionIds];\n            } else {\n              skippedActionIds = skippedActionIds.filter(id => id !== actionId);\n            }\n            // Optimization: we know history before this action hasn't changed\n            minInvalidatedStateIndex = stagedActionIds.indexOf(actionId);\n            break;\n          }\n        case ActionTypes.SET_ACTIONS_ACTIVE:\n          {\n            // Toggle whether an action with given ID is skipped.\n            // Being skipped means it is a no-op during the computation.\n            const {\n              start,\n              end,\n              active\n            } = liftedAction;\n            const actionIds = [];\n            for (let i = start; i < end; i++) actionIds.push(i);\n            if (active) {\n              skippedActionIds = difference(skippedActionIds, actionIds);\n            } else {\n              skippedActionIds = union(skippedActionIds, actionIds);\n            }\n\n            // Optimization: we know history before this action hasn't changed\n            minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n            break;\n          }\n        case ActionTypes.JUMP_TO_STATE:\n          {\n            // Without recomputing anything, move the pointer that tell us\n            // which state is considered the current one. Useful for sliders.\n            currentStateIndex = liftedAction.index;\n            // Optimization: we know the history has not changed.\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n        case ActionTypes.JUMP_TO_ACTION:\n          {\n            // Jumps to a corresponding state to a specific action.\n            // Useful when filtering actions.\n            const index = stagedActionIds.indexOf(liftedAction.actionId);\n            if (index !== -1) currentStateIndex = index;\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n        case ActionTypes.SWEEP:\n          {\n            // Forget any actions that are currently being skipped.\n            stagedActionIds = difference(stagedActionIds, skippedActionIds);\n            skippedActionIds = [];\n            currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);\n            break;\n          }\n        case ActionTypes.REORDER_ACTION:\n          {\n            // Recompute actions in a new order.\n            const actionId = liftedAction.actionId;\n            const idx = stagedActionIds.indexOf(actionId);\n            // do nothing in case the action is already removed or trying to move the first action\n            if (idx < 1) break;\n            const beforeActionId = liftedAction.beforeActionId;\n            let newIdx = stagedActionIds.indexOf(beforeActionId);\n            if (newIdx < 1) {\n              // move to the beginning or to the end\n              const count = stagedActionIds.length;\n              newIdx = beforeActionId > stagedActionIds[count - 1] ? count : 1;\n            }\n            const diff = idx - newIdx;\n            if (diff > 0) {\n              // move left\n              stagedActionIds = [...stagedActionIds.slice(0, newIdx), actionId, ...stagedActionIds.slice(newIdx, idx), ...stagedActionIds.slice(idx + 1)];\n              minInvalidatedStateIndex = newIdx;\n            } else if (diff < 0) {\n              // move right\n              stagedActionIds = [...stagedActionIds.slice(0, idx), ...stagedActionIds.slice(idx + 1, newIdx), actionId, ...stagedActionIds.slice(newIdx)];\n              minInvalidatedStateIndex = idx;\n            }\n            break;\n          }\n        case ActionTypes.IMPORT_STATE:\n          {\n            if (isArray(liftedAction.nextLiftedState)) {\n              // recompute array of actions\n              actionsById = {\n                0: liftAction(INIT_ACTION)\n              };\n              nextActionId = 1;\n              stagedActionIds = [0];\n              skippedActionIds = [];\n              currentStateIndex = liftedAction.nextLiftedState.length;\n              computedStates = [];\n              committedState = liftedAction.preloadedState;\n              minInvalidatedStateIndex = 0;\n              // iterate through actions\n              liftedAction.nextLiftedState.forEach(action => {\n                actionsById[nextActionId] = liftAction(action, options.trace || options.shouldIncludeCallstack);\n                stagedActionIds.push(nextActionId);\n                nextActionId++;\n              });\n            } else {\n              // Completely replace everything.\n              ({\n                monitorState,\n                actionsById,\n                nextActionId,\n                stagedActionIds,\n                skippedActionIds,\n                committedState,\n                currentStateIndex,\n                computedStates\n              } = liftedAction.nextLiftedState);\n              if (liftedAction.noRecompute) {\n                minInvalidatedStateIndex = Infinity;\n              }\n            }\n            break;\n          }\n        case ActionTypes.LOCK_CHANGES:\n          {\n            isLocked = liftedAction.status;\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n        case ActionTypes.PAUSE_RECORDING:\n          {\n            isPaused = liftedAction.status;\n            if (isPaused) {\n              return computePausedAction(true);\n            }\n            // Commit when unpausing\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = computedStates[currentStateIndex].state;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n        default:\n          {\n            // If the action is not recognized, it's a monitor action.\n            // Optimization: a monitor action can't change history.\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n      }\n    }\n    computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, options.shouldCatchErrors);\n    monitorState = monitorReducer(monitorState, liftedAction);\n    return {\n      monitorState,\n      actionsById,\n      nextActionId,\n      stagedActionIds,\n      skippedActionIds,\n      committedState,\n      currentStateIndex,\n      computedStates,\n      isLocked,\n      isPaused\n    };\n  };\n}\n\n/**\n * Provides an app's view into the state of the lifted store.\n */\nfunction unliftState(liftedState) {\n  const {\n    computedStates,\n    currentStateIndex\n  } = liftedState;\n  const {\n    state\n  } = computedStates[currentStateIndex];\n  return state;\n}\n/**\n * Provides an app's view into the lifted store.\n */\nfunction unliftStore(liftedStore, liftReducer, options) {\n  let lastDefinedState;\n  const trace = options.trace || options.shouldIncludeCallstack;\n  const traceLimit = options.traceLimit || 10;\n  function getState() {\n    const state = unliftState(liftedStore.getState());\n    if (state !== undefined) {\n      lastDefinedState = state;\n    }\n    return lastDefinedState;\n  }\n  function dispatch(action) {\n    liftedStore.dispatch(liftAction(action, trace, traceLimit, dispatch));\n    return action;\n  }\n  const $$observable = getSymbolObservable();\n  if (!($$observable in liftedStore)) {\n    console.warn('Symbol.observable as defined by Redux and Redux DevTools do not match. This could cause your app to behave differently if the DevTools are not loaded. Consider polyfilling Symbol.observable before Redux is imported or avoid polyfilling Symbol.observable altogether.');\n  }\n  return {\n    liftedStore,\n    dispatch,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    subscribe: liftedStore.subscribe,\n    getState,\n    replaceReducer(nextReducer) {\n      liftedStore.replaceReducer(liftReducer(nextReducer));\n    },\n    [$$observable]() {\n      return {\n        subscribe(observer) {\n          if (typeof observer !== 'object') {\n            throw new TypeError('Expected the observer to be an object.');\n          }\n          function observeState() {\n            if (observer.next) {\n              observer.next(getState());\n            }\n          }\n          observeState();\n          const unsubscribe = liftedStore.subscribe(observeState);\n          return {\n            unsubscribe\n          };\n        },\n        [$$observable]() {\n          return this;\n        }\n      };\n    }\n  };\n}\n/**\n * Redux instrumentation store enhancer.\n */\nexport function instrument() {\n  let monitorReducer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => null;\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof options.maxAge === 'number' && options.maxAge < 2) {\n    throw new Error('DevTools.instrument({ maxAge }) option, if specified, ' + 'may not be less than 2.');\n  }\n  return createStore => (reducer, initialState) => {\n    function liftReducer(r) {\n      if (typeof r !== 'function') {\n        if (r && typeof r.default === 'function') {\n          throw new Error('Expected the reducer to be a function. ' + 'Instead got an object with a \"default\" field. ' + 'Did you pass a module instead of the default export? ' + 'Try passing require(...).default instead.');\n        }\n        throw new Error('Expected the reducer to be a function.');\n      }\n      return liftReducerWith(r, initialState, monitorReducer, options);\n    }\n    const liftedStore = createStore(liftReducer(reducer));\n    if (liftedStore.liftedStore) {\n      throw new Error('DevTools instrumentation should not be applied more than once. ' + 'Check your store configuration.');\n    }\n    return unliftStore(liftedStore, liftReducer, options);\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}