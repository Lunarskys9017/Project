{"ast":null,"code":"class ConsumableStream {\n  async next(timeout) {\n    let asyncIterator = this.createConsumer(timeout);\n    let result = await asyncIterator.next();\n    asyncIterator.return();\n    return result;\n  }\n  async once(timeout) {\n    let result = await this.next(timeout);\n    if (result.done) {\n      // If stream was ended, this function should never resolve unless\n      // there is a timeout; in that case, it should reject early.\n      if (timeout == null) {\n        await new Promise(() => {});\n      } else {\n        let error = new Error('Stream consumer operation timed out early because stream ended');\n        error.name = 'TimeoutError';\n        throw error;\n      }\n    }\n    return result.value;\n  }\n  createConsumer() {\n    throw new TypeError('Method must be overriden by subclass');\n  }\n  [Symbol.asyncIterator]() {\n    return this.createConsumer();\n  }\n}\nmodule.exports = ConsumableStream;","map":{"version":3,"names":["ConsumableStream","next","timeout","asyncIterator","createConsumer","result","return","once","done","Promise","error","Error","name","value","TypeError","Symbol","module","exports"],"sources":["C:/Users/bryan/Desktop/Mob/Projects Backup/Projects/my-app/node_modules/writable-consumable-stream/node_modules/consumable-stream/index.js"],"sourcesContent":["class ConsumableStream {\n  async next(timeout) {\n    let asyncIterator = this.createConsumer(timeout);\n    let result = await asyncIterator.next();\n    asyncIterator.return();\n    return result;\n  }\n\n  async once(timeout) {\n    let result = await this.next(timeout);\n    if (result.done) {\n      // If stream was ended, this function should never resolve unless\n      // there is a timeout; in that case, it should reject early.\n      if (timeout == null) {\n        await new Promise(() => {});\n      } else {\n        let error = new Error(\n          'Stream consumer operation timed out early because stream ended'\n        );\n        error.name = 'TimeoutError';\n        throw error;\n      }\n    }\n    return result.value;\n  }\n\n  createConsumer() {\n    throw new TypeError('Method must be overriden by subclass');\n  }\n\n  [Symbol.asyncIterator]() {\n    return this.createConsumer();\n  }\n}\n\nmodule.exports = ConsumableStream;\n\n"],"mappings":"AAAA,MAAMA,gBAAgB,CAAC;EACrB,MAAMC,IAAIA,CAACC,OAAO,EAAE;IAClB,IAAIC,aAAa,GAAG,IAAI,CAACC,cAAc,CAACF,OAAO,CAAC;IAChD,IAAIG,MAAM,GAAG,MAAMF,aAAa,CAACF,IAAI,CAAC,CAAC;IACvCE,aAAa,CAACG,MAAM,CAAC,CAAC;IACtB,OAAOD,MAAM;EACf;EAEA,MAAME,IAAIA,CAACL,OAAO,EAAE;IAClB,IAAIG,MAAM,GAAG,MAAM,IAAI,CAACJ,IAAI,CAACC,OAAO,CAAC;IACrC,IAAIG,MAAM,CAACG,IAAI,EAAE;MACf;MACA;MACA,IAAIN,OAAO,IAAI,IAAI,EAAE;QACnB,MAAM,IAAIO,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;MAC7B,CAAC,MAAM;QACL,IAAIC,KAAK,GAAG,IAAIC,KAAK,CACnB,gEACF,CAAC;QACDD,KAAK,CAACE,IAAI,GAAG,cAAc;QAC3B,MAAMF,KAAK;MACb;IACF;IACA,OAAOL,MAAM,CAACQ,KAAK;EACrB;EAEAT,cAAcA,CAAA,EAAG;IACf,MAAM,IAAIU,SAAS,CAAC,sCAAsC,CAAC;EAC7D;EAEA,CAACC,MAAM,CAACZ,aAAa,IAAI;IACvB,OAAO,IAAI,CAACC,cAAc,CAAC,CAAC;EAC9B;AACF;AAEAY,MAAM,CAACC,OAAO,GAAGjB,gBAAgB"},"metadata":{},"sourceType":"script","externalDependencies":[]}