{"ast":null,"code":"const StreamDemux = require('stream-demux');\nconst AsyncStreamEmitter = require('async-stream-emitter');\nconst AGChannel = require('ag-channel');\nconst AuthEngine = require('./auth');\nconst formatter = require('sc-formatter');\nconst AGTransport = require('./transport');\nconst LinkedList = require('linked-list');\nconst cloneDeep = require('clone-deep');\nconst Buffer = require('buffer/').Buffer;\nconst wait = require('./wait');\nconst scErrors = require('sc-errors');\nconst InvalidArgumentsError = scErrors.InvalidArgumentsError;\nconst InvalidMessageError = scErrors.InvalidMessageError;\nconst SocketProtocolError = scErrors.SocketProtocolError;\nconst TimeoutError = scErrors.TimeoutError;\nconst BadConnectionError = scErrors.BadConnectionError;\nfunction AGClientSocket(socketOptions) {\n  AsyncStreamEmitter.call(this);\n  let defaultOptions = {\n    path: '/socketcluster/',\n    secure: false,\n    protocolScheme: null,\n    socketPath: null,\n    autoConnect: true,\n    autoReconnect: true,\n    autoSubscribeOnConnect: true,\n    connectTimeout: 20000,\n    ackTimeout: 10000,\n    timestampRequests: false,\n    timestampParam: 't',\n    binaryType: 'arraybuffer',\n    batchOnHandshake: false,\n    batchOnHandshakeDuration: 100,\n    batchInterval: 50,\n    protocolVersion: 2,\n    wsOptions: {},\n    cloneData: false\n  };\n  let opts = Object.assign(defaultOptions, socketOptions);\n  if (opts.authTokenName == null) {\n    opts.authTokenName = this._generateAuthTokenNameFromURI(opts);\n  }\n  this.id = null;\n  this.version = opts.version || null;\n  this.protocolVersion = opts.protocolVersion;\n  this.state = this.CLOSED;\n  this.authState = this.UNAUTHENTICATED;\n  this.signedAuthToken = null;\n  this.authToken = null;\n  this.pendingReconnect = false;\n  this.pendingReconnectTimeout = null;\n  this.preparingPendingSubscriptions = false;\n  this.clientId = opts.clientId;\n  this.wsOptions = opts.wsOptions;\n  this.connectTimeout = opts.connectTimeout;\n  this.ackTimeout = opts.ackTimeout;\n  this.channelPrefix = opts.channelPrefix || null;\n  this.authTokenName = opts.authTokenName;\n\n  // pingTimeout will be connectTimeout at the start, but it will\n  // be updated with values provided by the 'connect' event\n  opts.pingTimeout = opts.connectTimeout;\n  this.pingTimeout = opts.pingTimeout;\n  this.pingTimeoutDisabled = !!opts.pingTimeoutDisabled;\n  let maxTimeout = Math.pow(2, 31) - 1;\n  let verifyDuration = propertyName => {\n    if (this[propertyName] > maxTimeout) {\n      throw new InvalidArgumentsError(`The ${propertyName} value provided exceeded the maximum amount allowed`);\n    }\n  };\n  verifyDuration('connectTimeout');\n  verifyDuration('ackTimeout');\n  verifyDuration('pingTimeout');\n  this.connectAttempts = 0;\n  this.isBatching = false;\n  this.batchOnHandshake = opts.batchOnHandshake;\n  this.batchOnHandshakeDuration = opts.batchOnHandshakeDuration;\n  this._batchingIntervalId = null;\n  this._outboundBuffer = new LinkedList();\n  this._channelMap = {};\n  this._channelEventDemux = new StreamDemux();\n  this._channelDataDemux = new StreamDemux();\n  this._receiverDemux = new StreamDemux();\n  this._procedureDemux = new StreamDemux();\n  this.options = opts;\n  this._cid = 1;\n  this.options.callIdGenerator = () => {\n    return this._cid++;\n  };\n  if (this.options.autoReconnect) {\n    if (this.options.autoReconnectOptions == null) {\n      this.options.autoReconnectOptions = {};\n    }\n\n    // Add properties to the this.options.autoReconnectOptions object.\n    // We assign the reference to a reconnectOptions variable to avoid repetition.\n    let reconnectOptions = this.options.autoReconnectOptions;\n    if (reconnectOptions.initialDelay == null) {\n      reconnectOptions.initialDelay = 10000;\n    }\n    if (reconnectOptions.randomness == null) {\n      reconnectOptions.randomness = 10000;\n    }\n    if (reconnectOptions.multiplier == null) {\n      reconnectOptions.multiplier = 1.5;\n    }\n    if (reconnectOptions.maxDelay == null) {\n      reconnectOptions.maxDelay = 60000;\n    }\n  }\n  if (this.options.subscriptionRetryOptions == null) {\n    this.options.subscriptionRetryOptions = {};\n  }\n  if (this.options.authEngine) {\n    this.auth = this.options.authEngine;\n  } else {\n    this.auth = new AuthEngine();\n  }\n  if (this.options.codecEngine) {\n    this.codec = this.options.codecEngine;\n  } else {\n    // Default codec engine\n    this.codec = formatter;\n  }\n  if (this.options.protocol) {\n    let protocolOptionError = new InvalidArgumentsError('The protocol option does not affect socketcluster-client - ' + 'If you want to utilize SSL/TLS, use the secure option instead');\n    this._onError(protocolOptionError);\n  }\n  this.options.query = opts.query || {};\n  if (typeof this.options.query === 'string') {\n    let searchParams = new URLSearchParams(this.options.query);\n    let queryObject = {};\n    for (let [key, value] of searchParams.entries()) {\n      let currentValue = queryObject[key];\n      if (currentValue == null) {\n        queryObject[key] = value;\n      } else {\n        if (!Array.isArray(currentValue)) {\n          queryObject[key] = [currentValue];\n        }\n        queryObject[key].push(value);\n      }\n    }\n    this.options.query = queryObject;\n  }\n  if (this.options.autoConnect) {\n    this.connect();\n  }\n}\nAGClientSocket.prototype = Object.create(AsyncStreamEmitter.prototype);\nAGClientSocket.CONNECTING = AGClientSocket.prototype.CONNECTING = AGTransport.prototype.CONNECTING;\nAGClientSocket.OPEN = AGClientSocket.prototype.OPEN = AGTransport.prototype.OPEN;\nAGClientSocket.CLOSED = AGClientSocket.prototype.CLOSED = AGTransport.prototype.CLOSED;\nAGClientSocket.AUTHENTICATED = AGClientSocket.prototype.AUTHENTICATED = 'authenticated';\nAGClientSocket.UNAUTHENTICATED = AGClientSocket.prototype.UNAUTHENTICATED = 'unauthenticated';\nAGClientSocket.SUBSCRIBED = AGClientSocket.prototype.SUBSCRIBED = AGChannel.SUBSCRIBED;\nAGClientSocket.PENDING = AGClientSocket.prototype.PENDING = AGChannel.PENDING;\nAGClientSocket.UNSUBSCRIBED = AGClientSocket.prototype.UNSUBSCRIBED = AGChannel.UNSUBSCRIBED;\nAGClientSocket.ignoreStatuses = scErrors.socketProtocolIgnoreStatuses;\nAGClientSocket.errorStatuses = scErrors.socketProtocolErrorStatuses;\nObject.defineProperty(AGClientSocket.prototype, 'isBufferingBatch', {\n  get: function () {\n    return this.transport.isBufferingBatch;\n  }\n});\nAGClientSocket.prototype.uri = function () {\n  return AGTransport.computeURI(this.options);\n};\nAGClientSocket.prototype.getBackpressure = function () {\n  return Math.max(this.getAllListenersBackpressure(), this.getAllReceiversBackpressure(), this.getAllProceduresBackpressure(), this.getAllChannelsBackpressure());\n};\nAGClientSocket.prototype._generateAuthTokenNameFromURI = function (options) {\n  let authHostString = options.host ? `.${options.host}` : `.${options.hostname || 'localhost'}${options.port ? `:${options.port}` : ''}`;\n  return `socketcluster.authToken${authHostString}`;\n};\nAGClientSocket.prototype._setAuthToken = function (data) {\n  this._changeToAuthenticatedState(data.token);\n  (async () => {\n    try {\n      await this.auth.saveToken(this.authTokenName, data.token, {});\n    } catch (err) {\n      this._onError(err);\n    }\n  })();\n};\nAGClientSocket.prototype._removeAuthToken = function (data) {\n  (async () => {\n    let oldAuthToken;\n    try {\n      oldAuthToken = await this.auth.removeToken(this.authTokenName);\n    } catch (err) {\n      // Non-fatal error - Do not close the connection\n      this._onError(err);\n      return;\n    }\n    this.emit('removeAuthToken', {\n      oldAuthToken\n    });\n  })();\n  this._changeToUnauthenticatedStateAndClearTokens();\n};\nAGClientSocket.prototype._privateDataHandlerMap = {\n  '#publish': function (data) {\n    if (typeof data.channel !== 'string') return;\n    let undecoratedChannelName = this._undecorateChannelName(data.channel);\n    let isSubscribed = this.isSubscribed(undecoratedChannelName, true);\n    if (isSubscribed) {\n      this._channelDataDemux.write(undecoratedChannelName, data.data);\n    }\n  },\n  '#kickOut': function (data) {\n    if (typeof data.channel !== 'string') return;\n    let undecoratedChannelName = this._undecorateChannelName(data.channel);\n    let channel = this._channelMap[undecoratedChannelName];\n    if (channel) {\n      this.emit('kickOut', {\n        channel: undecoratedChannelName,\n        message: data.message\n      });\n      this._channelEventDemux.write(`${undecoratedChannelName}/kickOut`, {\n        message: data.message\n      });\n      this._triggerChannelUnsubscribe(channel);\n    }\n  },\n  '#setAuthToken': function (data) {\n    if (data) {\n      this._setAuthToken(data);\n    }\n  },\n  '#removeAuthToken': function (data) {\n    this._removeAuthToken(data);\n  }\n};\nAGClientSocket.prototype._privateRPCHandlerMap = {\n  '#setAuthToken': function (data, request) {\n    if (data) {\n      this._setAuthToken(data);\n      request.end();\n    } else {\n      let error = new InvalidMessageError('No token data provided by #setAuthToken event');\n      delete error.stack;\n      request.error(error);\n    }\n  },\n  '#removeAuthToken': function (data, request) {\n    this._removeAuthToken(data);\n    request.end();\n  }\n};\nAGClientSocket.prototype.getState = function () {\n  return this.state;\n};\nAGClientSocket.prototype.getBytesReceived = function () {\n  return this.transport.getBytesReceived();\n};\nAGClientSocket.prototype.deauthenticate = async function () {\n  (async () => {\n    let oldAuthToken;\n    try {\n      oldAuthToken = await this.auth.removeToken(this.authTokenName);\n    } catch (err) {\n      this._onError(err);\n      return;\n    }\n    this.emit('removeAuthToken', {\n      oldAuthToken\n    });\n  })();\n  if (this.state !== this.CLOSED) {\n    this.transmit('#removeAuthToken');\n  }\n  this._changeToUnauthenticatedStateAndClearTokens();\n  await wait(0);\n};\nAGClientSocket.prototype.connect = function (socketOptions) {\n  if (socketOptions) {\n    if (this.state !== this.CLOSED) {\n      this.disconnect(1000, 'Socket was disconnected by the client to initiate a new connection');\n    }\n    this.options = {\n      ...this.options,\n      ...socketOptions\n    };\n    if (this.options.authTokenName == null) {\n      this.options.authTokenName = this._generateAuthTokenNameFromURI(this.options);\n    }\n  }\n  if (this.state === this.CLOSED) {\n    this.pendingReconnect = false;\n    this.pendingReconnectTimeout = null;\n    clearTimeout(this._reconnectTimeoutRef);\n    this.state = this.CONNECTING;\n    this.emit('connecting', {});\n    if (this.transport) {\n      this.transport.clearAllListeners();\n    }\n    let transportHandlers = {\n      onOpen: value => {\n        this.state = this.OPEN;\n        this._onOpen(value);\n      },\n      onOpenAbort: value => {\n        if (this.state !== this.CLOSED) {\n          this.state = this.CLOSED;\n          this._destroy(value.code, value.reason, true);\n        }\n      },\n      onClose: value => {\n        if (this.state !== this.CLOSED) {\n          this.state = this.CLOSED;\n          this._destroy(value.code, value.reason);\n        }\n      },\n      onEvent: value => {\n        this.emit(value.event, value.data);\n      },\n      onError: value => {\n        this._onError(value.error);\n      },\n      onInboundInvoke: value => {\n        this._onInboundInvoke(value);\n      },\n      onInboundTransmit: value => {\n        this._onInboundTransmit(value.event, value.data);\n      }\n    };\n    this.transport = new AGTransport(this.auth, this.codec, this.options, this.wsOptions, transportHandlers);\n  }\n};\nAGClientSocket.prototype.reconnect = function (code, reason) {\n  this.disconnect(code, reason);\n  this.connect();\n};\nAGClientSocket.prototype.disconnect = function (code, reason) {\n  code = code || 1000;\n  if (typeof code !== 'number') {\n    throw new InvalidArgumentsError('If specified, the code argument must be a number');\n  }\n  let isConnecting = this.state === this.CONNECTING;\n  if (isConnecting || this.state === this.OPEN) {\n    this.state = this.CLOSED;\n    this._destroy(code, reason, isConnecting);\n    this.transport.close(code, reason);\n  } else {\n    this.pendingReconnect = false;\n    this.pendingReconnectTimeout = null;\n    clearTimeout(this._reconnectTimeoutRef);\n  }\n};\nAGClientSocket.prototype._changeToUnauthenticatedStateAndClearTokens = function () {\n  if (this.authState !== this.UNAUTHENTICATED) {\n    let oldAuthState = this.authState;\n    let oldAuthToken = this.authToken;\n    let oldSignedAuthToken = this.signedAuthToken;\n    this.authState = this.UNAUTHENTICATED;\n    this.signedAuthToken = null;\n    this.authToken = null;\n    let stateChangeData = {\n      oldAuthState,\n      newAuthState: this.authState\n    };\n    this.emit('authStateChange', stateChangeData);\n    this.emit('deauthenticate', {\n      oldSignedAuthToken,\n      oldAuthToken\n    });\n  }\n};\nAGClientSocket.prototype._changeToAuthenticatedState = function (signedAuthToken) {\n  this.signedAuthToken = signedAuthToken;\n  this.authToken = this._extractAuthTokenData(signedAuthToken);\n  if (this.authState !== this.AUTHENTICATED) {\n    let oldAuthState = this.authState;\n    this.authState = this.AUTHENTICATED;\n    let stateChangeData = {\n      oldAuthState,\n      newAuthState: this.authState,\n      signedAuthToken: signedAuthToken,\n      authToken: this.authToken\n    };\n    if (!this.preparingPendingSubscriptions) {\n      this.processPendingSubscriptions();\n    }\n    this.emit('authStateChange', stateChangeData);\n  }\n  this.emit('authenticate', {\n    signedAuthToken,\n    authToken: this.authToken\n  });\n};\nAGClientSocket.prototype.decodeBase64 = function (encodedString) {\n  return Buffer.from(encodedString, 'base64').toString('utf8');\n};\nAGClientSocket.prototype.encodeBase64 = function (decodedString) {\n  return Buffer.from(decodedString, 'utf8').toString('base64');\n};\nAGClientSocket.prototype._extractAuthTokenData = function (signedAuthToken) {\n  if (typeof signedAuthToken !== 'string') return null;\n  let tokenParts = signedAuthToken.split('.');\n  let encodedTokenData = tokenParts[1];\n  if (encodedTokenData != null) {\n    let tokenData = encodedTokenData;\n    try {\n      tokenData = this.decodeBase64(tokenData);\n      return JSON.parse(tokenData);\n    } catch (e) {\n      return tokenData;\n    }\n  }\n  return null;\n};\nAGClientSocket.prototype.getAuthToken = function () {\n  return this.authToken;\n};\nAGClientSocket.prototype.getSignedAuthToken = function () {\n  return this.signedAuthToken;\n};\n\n// Perform client-initiated authentication by providing an encrypted token string.\nAGClientSocket.prototype.authenticate = async function (signedAuthToken) {\n  let authStatus;\n  try {\n    authStatus = await this.invoke('#authenticate', signedAuthToken);\n  } catch (err) {\n    if (err.name !== 'BadConnectionError' && err.name !== 'TimeoutError') {\n      // In case of a bad/closed connection or a timeout, we maintain the last\n      // known auth state since those errors don't mean that the token is invalid.\n      this._changeToUnauthenticatedStateAndClearTokens();\n    }\n    await wait(0);\n    throw err;\n  }\n  if (authStatus && authStatus.isAuthenticated != null) {\n    // If authStatus is correctly formatted (has an isAuthenticated property),\n    // then we will rehydrate the authError.\n    if (authStatus.authError) {\n      authStatus.authError = scErrors.hydrateError(authStatus.authError);\n    }\n  } else {\n    // Some errors like BadConnectionError and TimeoutError will not pass a valid\n    // authStatus object to the current function, so we need to create it ourselves.\n    authStatus = {\n      isAuthenticated: this.authState,\n      authError: null\n    };\n  }\n  if (authStatus.isAuthenticated) {\n    this._changeToAuthenticatedState(signedAuthToken);\n  } else {\n    this._changeToUnauthenticatedStateAndClearTokens();\n  }\n  (async () => {\n    try {\n      await this.auth.saveToken(this.authTokenName, signedAuthToken, {});\n    } catch (err) {\n      this._onError(err);\n    }\n  })();\n  await wait(0);\n  return authStatus;\n};\nAGClientSocket.prototype._tryReconnect = function (initialDelay) {\n  let exponent = this.connectAttempts++;\n  let reconnectOptions = this.options.autoReconnectOptions;\n  let timeout;\n  if (initialDelay == null || exponent > 0) {\n    let initialTimeout = Math.round(reconnectOptions.initialDelay + (reconnectOptions.randomness || 0) * Math.random());\n    timeout = Math.round(initialTimeout * Math.pow(reconnectOptions.multiplier, exponent));\n  } else {\n    timeout = initialDelay;\n  }\n  if (timeout > reconnectOptions.maxDelay) {\n    timeout = reconnectOptions.maxDelay;\n  }\n  clearTimeout(this._reconnectTimeoutRef);\n  this.pendingReconnect = true;\n  this.pendingReconnectTimeout = timeout;\n  this._reconnectTimeoutRef = setTimeout(() => {\n    this.connect();\n  }, timeout);\n};\nAGClientSocket.prototype._onOpen = function (status) {\n  if (this.isBatching) {\n    this._startBatching();\n  } else if (this.batchOnHandshake) {\n    this._startBatching();\n    setTimeout(() => {\n      if (!this.isBatching) {\n        this._stopBatching();\n      }\n    }, this.batchOnHandshakeDuration);\n  }\n  this.preparingPendingSubscriptions = true;\n  if (status) {\n    this.id = status.id;\n    this.pingTimeout = status.pingTimeout;\n    if (status.isAuthenticated) {\n      this._changeToAuthenticatedState(status.authToken);\n    } else {\n      this._changeToUnauthenticatedStateAndClearTokens();\n    }\n  } else {\n    // This can happen if auth.loadToken (in transport.js) fails with\n    // an error - This means that the signedAuthToken cannot be loaded by\n    // the auth engine and therefore, we need to unauthenticate the client.\n    this._changeToUnauthenticatedStateAndClearTokens();\n  }\n  this.connectAttempts = 0;\n  if (this.options.autoSubscribeOnConnect) {\n    this.processPendingSubscriptions();\n  }\n\n  // If the user invokes the callback while in autoSubscribeOnConnect mode, it\n  // won't break anything.\n  this.emit('connect', {\n    ...status,\n    processPendingSubscriptions: () => {\n      this.processPendingSubscriptions();\n    }\n  });\n  if (this.state === this.OPEN) {\n    this._flushOutboundBuffer();\n  }\n};\nAGClientSocket.prototype._onError = function (error) {\n  this.emit('error', {\n    error\n  });\n};\nAGClientSocket.prototype._suspendSubscriptions = function () {\n  Object.keys(this._channelMap).forEach(channelName => {\n    let channel = this._channelMap[channelName];\n    this._triggerChannelUnsubscribe(channel, true);\n  });\n};\nAGClientSocket.prototype._abortAllPendingEventsDueToBadConnection = function (failureType) {\n  let currentNode = this._outboundBuffer.head;\n  let nextNode;\n  while (currentNode) {\n    nextNode = currentNode.next;\n    let eventObject = currentNode.data;\n    clearTimeout(eventObject.timeout);\n    delete eventObject.timeout;\n    currentNode.detach();\n    currentNode = nextNode;\n    let callback = eventObject.callback;\n    if (callback) {\n      delete eventObject.callback;\n      let errorMessage = `Event ${eventObject.event} was aborted due to a bad connection`;\n      let error = new BadConnectionError(errorMessage, failureType);\n      callback.call(eventObject, error, eventObject);\n    }\n    // Cleanup any pending response callback in the transport layer too.\n    if (eventObject.cid) {\n      this.transport.cancelPendingResponse(eventObject.cid);\n    }\n  }\n};\nAGClientSocket.prototype._destroy = function (code, reason, openAbort) {\n  this.id = null;\n  this._cancelBatching();\n  if (this.transport) {\n    this.transport.clearAllListeners();\n  }\n  this.pendingReconnect = false;\n  this.pendingReconnectTimeout = null;\n  clearTimeout(this._reconnectTimeoutRef);\n  this._suspendSubscriptions();\n  if (openAbort) {\n    this.emit('connectAbort', {\n      code,\n      reason\n    });\n  } else {\n    this.emit('disconnect', {\n      code,\n      reason\n    });\n  }\n  this.emit('close', {\n    code,\n    reason\n  });\n  if (!AGClientSocket.ignoreStatuses[code]) {\n    let closeMessage;\n    if (typeof reason === 'string') {\n      closeMessage = 'Socket connection closed with status code ' + code + ' and reason: ' + reason;\n    } else {\n      closeMessage = 'Socket connection closed with status code ' + code;\n    }\n    let err = new SocketProtocolError(AGClientSocket.errorStatuses[code] || closeMessage, code);\n    this._onError(err);\n  }\n  this._abortAllPendingEventsDueToBadConnection(openAbort ? 'connectAbort' : 'disconnect');\n\n  // Try to reconnect\n  // on server ping timeout (4000)\n  // or on client pong timeout (4001)\n  // or on close without status (1005)\n  // or on handshake failure (4003)\n  // or on handshake rejection (4008)\n  // or on socket hung up (1006)\n  if (this.options.autoReconnect) {\n    if (code === 4000 || code === 4001 || code === 1005) {\n      // If there is a ping or pong timeout or socket closes without\n      // status, don't wait before trying to reconnect - These could happen\n      // if the client wakes up after a period of inactivity and in this case we\n      // want to re-establish the connection as soon as possible.\n      this._tryReconnect(0);\n\n      // Codes 4500 and above will be treated as permanent disconnects.\n      // Socket will not try to auto-reconnect.\n    } else if (code !== 1000 && code < 4500) {\n      this._tryReconnect();\n    }\n  }\n};\nAGClientSocket.prototype._onInboundTransmit = function (event, data) {\n  let handler = this._privateDataHandlerMap[event];\n  if (handler) {\n    handler.call(this, data || {});\n  } else {\n    this._receiverDemux.write(event, data);\n  }\n};\nAGClientSocket.prototype._onInboundInvoke = function (request) {\n  let {\n    procedure,\n    data\n  } = request;\n  let handler = this._privateRPCHandlerMap[procedure];\n  if (handler) {\n    handler.call(this, data, request);\n  } else {\n    this._procedureDemux.write(procedure, request);\n  }\n};\nAGClientSocket.prototype.decode = function (message) {\n  return this.transport.decode(message);\n};\nAGClientSocket.prototype.encode = function (object) {\n  return this.transport.encode(object);\n};\nAGClientSocket.prototype._flushOutboundBuffer = function () {\n  let currentNode = this._outboundBuffer.head;\n  let nextNode;\n  while (currentNode) {\n    nextNode = currentNode.next;\n    let eventObject = currentNode.data;\n    currentNode.detach();\n    this.transport.transmitObject(eventObject);\n    currentNode = nextNode;\n  }\n};\nAGClientSocket.prototype._handleEventAckTimeout = function (eventObject, eventNode) {\n  if (eventNode) {\n    eventNode.detach();\n  }\n  delete eventObject.timeout;\n  let callback = eventObject.callback;\n  if (callback) {\n    delete eventObject.callback;\n    let error = new TimeoutError(`Event response for ${eventObject.event} event timed out`);\n    callback.call(eventObject, error, eventObject);\n  }\n  // Cleanup any pending response callback in the transport layer too.\n  if (eventObject.cid) {\n    this.transport.cancelPendingResponse(eventObject.cid);\n  }\n};\nAGClientSocket.prototype._processOutboundEvent = function (event, data, options, expectResponse) {\n  options = options || {};\n  if (this.state === this.CLOSED) {\n    this.connect();\n  }\n  let eventObject = {\n    event\n  };\n  let promise;\n  if (expectResponse) {\n    promise = new Promise((resolve, reject) => {\n      eventObject.callback = (err, data) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(data);\n      };\n    });\n  } else {\n    promise = Promise.resolve();\n  }\n  let eventNode = new LinkedList.Item();\n  if (this.options.cloneData) {\n    eventObject.data = cloneDeep(data);\n  } else {\n    eventObject.data = data;\n  }\n  eventNode.data = eventObject;\n  let ackTimeout = options.ackTimeout == null ? this.ackTimeout : options.ackTimeout;\n  eventObject.timeout = setTimeout(() => {\n    this._handleEventAckTimeout(eventObject, eventNode);\n  }, ackTimeout);\n  this._outboundBuffer.append(eventNode);\n  if (this.state === this.OPEN) {\n    this._flushOutboundBuffer();\n  }\n  return promise;\n};\nAGClientSocket.prototype.send = function (data) {\n  this.transport.send(data);\n};\nAGClientSocket.prototype.transmit = function (event, data, options) {\n  return this._processOutboundEvent(event, data, options);\n};\nAGClientSocket.prototype.invoke = function (event, data, options) {\n  return this._processOutboundEvent(event, data, options, true);\n};\nAGClientSocket.prototype.transmitPublish = function (channelName, data) {\n  let pubData = {\n    channel: this._decorateChannelName(channelName),\n    data\n  };\n  return this.transmit('#publish', pubData);\n};\nAGClientSocket.prototype.invokePublish = function (channelName, data) {\n  let pubData = {\n    channel: this._decorateChannelName(channelName),\n    data\n  };\n  return this.invoke('#publish', pubData);\n};\nAGClientSocket.prototype._triggerChannelSubscribe = function (channel, subscriptionOptions) {\n  let channelName = channel.name;\n  if (channel.state !== AGChannel.SUBSCRIBED) {\n    let oldChannelState = channel.state;\n    channel.state = AGChannel.SUBSCRIBED;\n    let stateChangeData = {\n      oldChannelState,\n      newChannelState: channel.state,\n      subscriptionOptions\n    };\n    this._channelEventDemux.write(`${channelName}/subscribeStateChange`, stateChangeData);\n    this._channelEventDemux.write(`${channelName}/subscribe`, {\n      subscriptionOptions\n    });\n    this.emit('subscribeStateChange', {\n      channel: channelName,\n      ...stateChangeData\n    });\n    this.emit('subscribe', {\n      channel: channelName,\n      subscriptionOptions\n    });\n  }\n};\nAGClientSocket.prototype._triggerChannelSubscribeFail = function (err, channel, subscriptionOptions) {\n  let channelName = channel.name;\n  let meetsAuthRequirements = !channel.options.waitForAuth || this.authState === this.AUTHENTICATED;\n  let hasChannel = !!this._channelMap[channelName];\n  if (hasChannel && meetsAuthRequirements) {\n    delete this._channelMap[channelName];\n    this._channelEventDemux.write(`${channelName}/subscribeFail`, {\n      error: err,\n      subscriptionOptions\n    });\n    this.emit('subscribeFail', {\n      error: err,\n      channel: channelName,\n      subscriptionOptions: subscriptionOptions\n    });\n  }\n};\n\n// Cancel any pending subscribe callback\nAGClientSocket.prototype._cancelPendingSubscribeCallback = function (channel) {\n  if (channel._pendingSubscriptionCid != null) {\n    this.transport.cancelPendingResponse(channel._pendingSubscriptionCid);\n    delete channel._pendingSubscriptionCid;\n  }\n};\nAGClientSocket.prototype._decorateChannelName = function (channelName) {\n  if (this.channelPrefix) {\n    channelName = this.channelPrefix + channelName;\n  }\n  return channelName;\n};\nAGClientSocket.prototype._undecorateChannelName = function (decoratedChannelName) {\n  if (this.channelPrefix && decoratedChannelName.indexOf(this.channelPrefix) === 0) {\n    return decoratedChannelName.replace(this.channelPrefix, '');\n  }\n  return decoratedChannelName;\n};\nAGClientSocket.prototype.startBatch = function () {\n  this.transport.startBatch();\n};\nAGClientSocket.prototype.flushBatch = function () {\n  this.transport.flushBatch();\n};\nAGClientSocket.prototype.cancelBatch = function () {\n  this.transport.cancelBatch();\n};\nAGClientSocket.prototype._startBatching = function () {\n  if (this._batchingIntervalId != null) {\n    return;\n  }\n  this.startBatch();\n  this._batchingIntervalId = setInterval(() => {\n    this.flushBatch();\n    this.startBatch();\n  }, this.options.batchInterval);\n};\nAGClientSocket.prototype.startBatching = function () {\n  this.isBatching = true;\n  this._startBatching();\n};\nAGClientSocket.prototype._stopBatching = function () {\n  if (this._batchingIntervalId != null) {\n    clearInterval(this._batchingIntervalId);\n  }\n  this._batchingIntervalId = null;\n  this.flushBatch();\n};\nAGClientSocket.prototype.stopBatching = function () {\n  this.isBatching = false;\n  this._stopBatching();\n};\nAGClientSocket.prototype._cancelBatching = function () {\n  if (this._batchingIntervalId != null) {\n    clearInterval(this._batchingIntervalId);\n  }\n  this._batchingIntervalId = null;\n  this.cancelBatch();\n};\nAGClientSocket.prototype.cancelBatching = function () {\n  this.isBatching = false;\n  this._cancelBatching();\n};\nAGClientSocket.prototype._trySubscribe = function (channel) {\n  let meetsAuthRequirements = !channel.options.waitForAuth || this.authState === this.AUTHENTICATED;\n\n  // We can only ever have one pending subscribe action at any given time on a channel\n  if (this.state === this.OPEN && !this.preparingPendingSubscriptions && channel._pendingSubscriptionCid == null && meetsAuthRequirements) {\n    let options = {\n      noTimeout: true\n    };\n    let subscriptionOptions = {};\n    if (channel.options.waitForAuth) {\n      options.waitForAuth = true;\n      subscriptionOptions.waitForAuth = options.waitForAuth;\n    }\n    if (channel.options.data) {\n      subscriptionOptions.data = channel.options.data;\n    }\n    channel._pendingSubscriptionCid = this.transport.invokeRaw('#subscribe', {\n      channel: this._decorateChannelName(channel.name),\n      ...subscriptionOptions\n    }, options, err => {\n      if (err) {\n        if (err.name === 'BadConnectionError') {\n          // In case of a failed connection, keep the subscription\n          // as pending; it will try again on reconnect.\n          return;\n        }\n        delete channel._pendingSubscriptionCid;\n        this._triggerChannelSubscribeFail(err, channel, subscriptionOptions);\n      } else {\n        delete channel._pendingSubscriptionCid;\n        this._triggerChannelSubscribe(channel, subscriptionOptions);\n      }\n    });\n    this.emit('subscribeRequest', {\n      channel: channel.name,\n      subscriptionOptions\n    });\n  }\n};\nAGClientSocket.prototype.subscribe = function (channelName, options) {\n  options = options || {};\n  let channel = this._channelMap[channelName];\n  let sanitizedOptions = {\n    waitForAuth: !!options.waitForAuth\n  };\n  if (options.priority != null) {\n    sanitizedOptions.priority = options.priority;\n  }\n  if (options.data !== undefined) {\n    sanitizedOptions.data = options.data;\n  }\n  if (!channel) {\n    channel = {\n      name: channelName,\n      state: AGChannel.PENDING,\n      options: sanitizedOptions\n    };\n    this._channelMap[channelName] = channel;\n    this._trySubscribe(channel);\n  } else if (options) {\n    channel.options = sanitizedOptions;\n  }\n  let channelIterable = new AGChannel(channelName, this, this._channelEventDemux, this._channelDataDemux);\n  return channelIterable;\n};\nAGClientSocket.prototype._triggerChannelUnsubscribe = function (channel, setAsPending) {\n  let channelName = channel.name;\n  this._cancelPendingSubscribeCallback(channel);\n  if (channel.state === AGChannel.SUBSCRIBED) {\n    let stateChangeData = {\n      oldChannelState: channel.state,\n      newChannelState: setAsPending ? AGChannel.PENDING : AGChannel.UNSUBSCRIBED\n    };\n    this._channelEventDemux.write(`${channelName}/subscribeStateChange`, stateChangeData);\n    this._channelEventDemux.write(`${channelName}/unsubscribe`, {});\n    this.emit('subscribeStateChange', {\n      channel: channelName,\n      ...stateChangeData\n    });\n    this.emit('unsubscribe', {\n      channel: channelName\n    });\n  }\n  if (setAsPending) {\n    channel.state = AGChannel.PENDING;\n  } else {\n    delete this._channelMap[channelName];\n  }\n};\nAGClientSocket.prototype._tryUnsubscribe = function (channel) {\n  if (this.state === this.OPEN) {\n    let options = {\n      noTimeout: true\n    };\n    // If there is a pending subscribe action, cancel the callback\n    this._cancelPendingSubscribeCallback(channel);\n\n    // This operation cannot fail because the TCP protocol guarantees delivery\n    // so long as the connection remains open. If the connection closes,\n    // the server will automatically unsubscribe the client and thus complete\n    // the operation on the server side.\n    let decoratedChannelName = this._decorateChannelName(channel.name);\n    this.transport.transmit('#unsubscribe', decoratedChannelName, options);\n  }\n};\nAGClientSocket.prototype.unsubscribe = function (channelName) {\n  let channel = this._channelMap[channelName];\n  if (channel) {\n    this._triggerChannelUnsubscribe(channel);\n    this._tryUnsubscribe(channel);\n  }\n};\n\n// ---- Receiver logic ----\n\nAGClientSocket.prototype.receiver = function (receiverName) {\n  return this._receiverDemux.stream(receiverName);\n};\nAGClientSocket.prototype.closeReceiver = function (receiverName) {\n  this._receiverDemux.close(receiverName);\n};\nAGClientSocket.prototype.closeAllReceivers = function () {\n  this._receiverDemux.closeAll();\n};\nAGClientSocket.prototype.killReceiver = function (receiverName) {\n  this._receiverDemux.kill(receiverName);\n};\nAGClientSocket.prototype.killAllReceivers = function () {\n  this._receiverDemux.killAll();\n};\nAGClientSocket.prototype.killReceiverConsumer = function (consumerId) {\n  this._receiverDemux.killConsumer(consumerId);\n};\nAGClientSocket.prototype.getReceiverConsumerStats = function (consumerId) {\n  return this._receiverDemux.getConsumerStats(consumerId);\n};\nAGClientSocket.prototype.getReceiverConsumerStatsList = function (receiverName) {\n  return this._receiverDemux.getConsumerStatsList(receiverName);\n};\nAGClientSocket.prototype.getAllReceiversConsumerStatsList = function () {\n  return this._receiverDemux.getConsumerStatsListAll();\n};\nAGClientSocket.prototype.getReceiverBackpressure = function (receiverName) {\n  return this._receiverDemux.getBackpressure(receiverName);\n};\nAGClientSocket.prototype.getAllReceiversBackpressure = function () {\n  return this._receiverDemux.getBackpressureAll();\n};\nAGClientSocket.prototype.getReceiverConsumerBackpressure = function (consumerId) {\n  return this._receiverDemux.getConsumerBackpressure(consumerId);\n};\nAGClientSocket.prototype.hasReceiverConsumer = function (receiverName, consumerId) {\n  return this._receiverDemux.hasConsumer(receiverName, consumerId);\n};\nAGClientSocket.prototype.hasAnyReceiverConsumer = function (consumerId) {\n  return this._receiverDemux.hasConsumerAll(consumerId);\n};\n\n// ---- Procedure logic ----\n\nAGClientSocket.prototype.procedure = function (procedureName) {\n  return this._procedureDemux.stream(procedureName);\n};\nAGClientSocket.prototype.closeProcedure = function (procedureName) {\n  this._procedureDemux.close(procedureName);\n};\nAGClientSocket.prototype.closeAllProcedures = function () {\n  this._procedureDemux.closeAll();\n};\nAGClientSocket.prototype.killProcedure = function (procedureName) {\n  this._procedureDemux.kill(procedureName);\n};\nAGClientSocket.prototype.killAllProcedures = function () {\n  this._procedureDemux.killAll();\n};\nAGClientSocket.prototype.killProcedureConsumer = function (consumerId) {\n  this._procedureDemux.killConsumer(consumerId);\n};\nAGClientSocket.prototype.getProcedureConsumerStats = function (consumerId) {\n  return this._procedureDemux.getConsumerStats(consumerId);\n};\nAGClientSocket.prototype.getProcedureConsumerStatsList = function (procedureName) {\n  return this._procedureDemux.getConsumerStatsList(procedureName);\n};\nAGClientSocket.prototype.getAllProceduresConsumerStatsList = function () {\n  return this._procedureDemux.getConsumerStatsListAll();\n};\nAGClientSocket.prototype.getProcedureBackpressure = function (procedureName) {\n  return this._procedureDemux.getBackpressure(procedureName);\n};\nAGClientSocket.prototype.getAllProceduresBackpressure = function () {\n  return this._procedureDemux.getBackpressureAll();\n};\nAGClientSocket.prototype.getProcedureConsumerBackpressure = function (consumerId) {\n  return this._procedureDemux.getConsumerBackpressure(consumerId);\n};\nAGClientSocket.prototype.hasProcedureConsumer = function (procedureName, consumerId) {\n  return this._procedureDemux.hasConsumer(procedureName, consumerId);\n};\nAGClientSocket.prototype.hasAnyProcedureConsumer = function (consumerId) {\n  return this._procedureDemux.hasConsumerAll(consumerId);\n};\n\n// ---- Channel logic ----\n\nAGClientSocket.prototype.channel = function (channelName) {\n  let currentChannel = this._channelMap[channelName];\n  let channelIterable = new AGChannel(channelName, this, this._channelEventDemux, this._channelDataDemux);\n  return channelIterable;\n};\nAGClientSocket.prototype.closeChannel = function (channelName) {\n  this.channelCloseOutput(channelName);\n  this.channelCloseAllListeners(channelName);\n};\nAGClientSocket.prototype.closeAllChannelOutputs = function () {\n  this._channelDataDemux.closeAll();\n};\nAGClientSocket.prototype.closeAllChannelListeners = function () {\n  this._channelEventDemux.closeAll();\n};\nAGClientSocket.prototype.closeAllChannels = function () {\n  this.closeAllChannelOutputs();\n  this.closeAllChannelListeners();\n};\nAGClientSocket.prototype.killChannel = function (channelName) {\n  this.channelKillOutput(channelName);\n  this.channelKillAllListeners(channelName);\n};\nAGClientSocket.prototype.killAllChannelOutputs = function () {\n  this._channelDataDemux.killAll();\n};\nAGClientSocket.prototype.killAllChannelListeners = function () {\n  this._channelEventDemux.killAll();\n};\nAGClientSocket.prototype.killAllChannels = function () {\n  this.killAllChannelOutputs();\n  this.killAllChannelListeners();\n};\nAGClientSocket.prototype.killChannelOutputConsumer = function (consumerId) {\n  this._channelDataDemux.killConsumer(consumerId);\n};\nAGClientSocket.prototype.killChannelListenerConsumer = function (consumerId) {\n  this._channelEventDemux.killConsumer(consumerId);\n};\nAGClientSocket.prototype.getChannelOutputConsumerStats = function (consumerId) {\n  return this._channelDataDemux.getConsumerStats(consumerId);\n};\nAGClientSocket.prototype.getChannelListenerConsumerStats = function (consumerId) {\n  return this._channelEventDemux.getConsumerStats(consumerId);\n};\nAGClientSocket.prototype.getAllChannelOutputsConsumerStatsList = function () {\n  return this._channelDataDemux.getConsumerStatsListAll();\n};\nAGClientSocket.prototype.getAllChannelListenersConsumerStatsList = function () {\n  return this._channelEventDemux.getConsumerStatsListAll();\n};\nAGClientSocket.prototype.getChannelBackpressure = function (channelName) {\n  return Math.max(this.channelGetOutputBackpressure(channelName), this.channelGetAllListenersBackpressure(channelName));\n};\nAGClientSocket.prototype.getAllChannelOutputsBackpressure = function () {\n  return this._channelDataDemux.getBackpressureAll();\n};\nAGClientSocket.prototype.getAllChannelListenersBackpressure = function () {\n  return this._channelEventDemux.getBackpressureAll();\n};\nAGClientSocket.prototype.getAllChannelsBackpressure = function () {\n  return Math.max(this.getAllChannelOutputsBackpressure(), this.getAllChannelListenersBackpressure());\n};\nAGClientSocket.prototype.getChannelListenerConsumerBackpressure = function (consumerId) {\n  return this._channelEventDemux.getConsumerBackpressure(consumerId);\n};\nAGClientSocket.prototype.getChannelOutputConsumerBackpressure = function (consumerId) {\n  return this._channelDataDemux.getConsumerBackpressure(consumerId);\n};\nAGClientSocket.prototype.hasAnyChannelOutputConsumer = function (consumerId) {\n  return this._channelDataDemux.hasConsumerAll(consumerId);\n};\nAGClientSocket.prototype.hasAnyChannelListenerConsumer = function (consumerId) {\n  return this._channelEventDemux.hasConsumerAll(consumerId);\n};\nAGClientSocket.prototype.getChannelState = function (channelName) {\n  let channel = this._channelMap[channelName];\n  if (channel) {\n    return channel.state;\n  }\n  return AGChannel.UNSUBSCRIBED;\n};\nAGClientSocket.prototype.getChannelOptions = function (channelName) {\n  let channel = this._channelMap[channelName];\n  if (channel) {\n    return {\n      ...channel.options\n    };\n  }\n  return {};\n};\nAGClientSocket.prototype._getAllChannelStreamNames = function (channelName) {\n  let streamNamesLookup = this._channelEventDemux.getConsumerStatsListAll().filter(stats => {\n    return stats.stream.indexOf(`${channelName}/`) === 0;\n  }).reduce((accumulator, stats) => {\n    accumulator[stats.stream] = true;\n    return accumulator;\n  }, {});\n  return Object.keys(streamNamesLookup);\n};\nAGClientSocket.prototype.channelCloseOutput = function (channelName) {\n  this._channelDataDemux.close(channelName);\n};\nAGClientSocket.prototype.channelCloseListener = function (channelName, eventName) {\n  this._channelEventDemux.close(`${channelName}/${eventName}`);\n};\nAGClientSocket.prototype.channelCloseAllListeners = function (channelName) {\n  let listenerStreams = this._getAllChannelStreamNames(channelName).forEach(streamName => {\n    this._channelEventDemux.close(streamName);\n  });\n};\nAGClientSocket.prototype.channelKillOutput = function (channelName) {\n  this._channelDataDemux.kill(channelName);\n};\nAGClientSocket.prototype.channelKillListener = function (channelName, eventName) {\n  this._channelEventDemux.kill(`${channelName}/${eventName}`);\n};\nAGClientSocket.prototype.channelKillAllListeners = function (channelName) {\n  let listenerStreams = this._getAllChannelStreamNames(channelName).forEach(streamName => {\n    this._channelEventDemux.kill(streamName);\n  });\n};\nAGClientSocket.prototype.channelGetOutputConsumerStatsList = function (channelName) {\n  return this._channelDataDemux.getConsumerStatsList(channelName);\n};\nAGClientSocket.prototype.channelGetListenerConsumerStatsList = function (channelName, eventName) {\n  return this._channelEventDemux.getConsumerStatsList(`${channelName}/${eventName}`);\n};\nAGClientSocket.prototype.channelGetAllListenersConsumerStatsList = function (channelName) {\n  return this._getAllChannelStreamNames(channelName).map(streamName => {\n    return this._channelEventDemux.getConsumerStatsList(streamName);\n  }).reduce((accumulator, statsList) => {\n    statsList.forEach(stats => {\n      accumulator.push(stats);\n    });\n    return accumulator;\n  }, []);\n};\nAGClientSocket.prototype.channelGetOutputBackpressure = function (channelName) {\n  return this._channelDataDemux.getBackpressure(channelName);\n};\nAGClientSocket.prototype.channelGetListenerBackpressure = function (channelName, eventName) {\n  return this._channelEventDemux.getBackpressure(`${channelName}/${eventName}`);\n};\nAGClientSocket.prototype.channelGetAllListenersBackpressure = function (channelName) {\n  let listenerStreamBackpressures = this._getAllChannelStreamNames(channelName).map(streamName => {\n    return this._channelEventDemux.getBackpressure(streamName);\n  });\n  return Math.max(...listenerStreamBackpressures.concat(0));\n};\nAGClientSocket.prototype.channelHasOutputConsumer = function (channelName, consumerId) {\n  return this._channelDataDemux.hasConsumer(channelName, consumerId);\n};\nAGClientSocket.prototype.channelHasListenerConsumer = function (channelName, eventName, consumerId) {\n  return this._channelEventDemux.hasConsumer(`${channelName}/${eventName}`, consumerId);\n};\nAGClientSocket.prototype.channelHasAnyListenerConsumer = function (channelName, consumerId) {\n  return this._getAllChannelStreamNames(channelName).some(streamName => {\n    return this._channelEventDemux.hasConsumer(streamName, consumerId);\n  });\n};\nAGClientSocket.prototype.subscriptions = function (includePending) {\n  let subs = [];\n  Object.keys(this._channelMap).forEach(channelName => {\n    if (includePending || this._channelMap[channelName].state === AGChannel.SUBSCRIBED) {\n      subs.push(channelName);\n    }\n  });\n  return subs;\n};\nAGClientSocket.prototype.isSubscribed = function (channelName, includePending) {\n  let channel = this._channelMap[channelName];\n  if (includePending) {\n    return !!channel;\n  }\n  return !!channel && channel.state === AGChannel.SUBSCRIBED;\n};\nAGClientSocket.prototype.processPendingSubscriptions = function () {\n  this.preparingPendingSubscriptions = false;\n  let pendingChannels = [];\n  Object.keys(this._channelMap).forEach(channelName => {\n    let channel = this._channelMap[channelName];\n    if (channel.state === AGChannel.PENDING) {\n      pendingChannels.push(channel);\n    }\n  });\n  pendingChannels.sort((a, b) => {\n    let ap = a.options.priority || 0;\n    let bp = b.options.priority || 0;\n    if (ap > bp) {\n      return -1;\n    }\n    if (ap < bp) {\n      return 1;\n    }\n    return 0;\n  });\n  pendingChannels.forEach(channel => {\n    this._trySubscribe(channel);\n  });\n};\nmodule.exports = AGClientSocket;","map":{"version":3,"names":["StreamDemux","require","AsyncStreamEmitter","AGChannel","AuthEngine","formatter","AGTransport","LinkedList","cloneDeep","Buffer","wait","scErrors","InvalidArgumentsError","InvalidMessageError","SocketProtocolError","TimeoutError","BadConnectionError","AGClientSocket","socketOptions","call","defaultOptions","path","secure","protocolScheme","socketPath","autoConnect","autoReconnect","autoSubscribeOnConnect","connectTimeout","ackTimeout","timestampRequests","timestampParam","binaryType","batchOnHandshake","batchOnHandshakeDuration","batchInterval","protocolVersion","wsOptions","cloneData","opts","Object","assign","authTokenName","_generateAuthTokenNameFromURI","id","version","state","CLOSED","authState","UNAUTHENTICATED","signedAuthToken","authToken","pendingReconnect","pendingReconnectTimeout","preparingPendingSubscriptions","clientId","channelPrefix","pingTimeout","pingTimeoutDisabled","maxTimeout","Math","pow","verifyDuration","propertyName","connectAttempts","isBatching","_batchingIntervalId","_outboundBuffer","_channelMap","_channelEventDemux","_channelDataDemux","_receiverDemux","_procedureDemux","options","_cid","callIdGenerator","autoReconnectOptions","reconnectOptions","initialDelay","randomness","multiplier","maxDelay","subscriptionRetryOptions","authEngine","auth","codecEngine","codec","protocol","protocolOptionError","_onError","query","searchParams","URLSearchParams","queryObject","key","value","entries","currentValue","Array","isArray","push","connect","prototype","create","CONNECTING","OPEN","AUTHENTICATED","SUBSCRIBED","PENDING","UNSUBSCRIBED","ignoreStatuses","socketProtocolIgnoreStatuses","errorStatuses","socketProtocolErrorStatuses","defineProperty","get","transport","isBufferingBatch","uri","computeURI","getBackpressure","max","getAllListenersBackpressure","getAllReceiversBackpressure","getAllProceduresBackpressure","getAllChannelsBackpressure","authHostString","host","hostname","port","_setAuthToken","data","_changeToAuthenticatedState","token","saveToken","err","_removeAuthToken","oldAuthToken","removeToken","emit","_changeToUnauthenticatedStateAndClearTokens","_privateDataHandlerMap","#publish","channel","undecoratedChannelName","_undecorateChannelName","isSubscribed","write","#kickOut","message","_triggerChannelUnsubscribe","#setAuthToken","#removeAuthToken","_privateRPCHandlerMap","request","end","error","stack","getState","getBytesReceived","deauthenticate","transmit","disconnect","clearTimeout","_reconnectTimeoutRef","clearAllListeners","transportHandlers","onOpen","_onOpen","onOpenAbort","_destroy","code","reason","onClose","onEvent","event","onError","onInboundInvoke","_onInboundInvoke","onInboundTransmit","_onInboundTransmit","reconnect","isConnecting","close","oldAuthState","oldSignedAuthToken","stateChangeData","newAuthState","_extractAuthTokenData","processPendingSubscriptions","decodeBase64","encodedString","from","toString","encodeBase64","decodedString","tokenParts","split","encodedTokenData","tokenData","JSON","parse","e","getAuthToken","getSignedAuthToken","authenticate","authStatus","invoke","name","isAuthenticated","authError","hydrateError","_tryReconnect","exponent","timeout","initialTimeout","round","random","setTimeout","status","_startBatching","_stopBatching","_flushOutboundBuffer","_suspendSubscriptions","keys","forEach","channelName","_abortAllPendingEventsDueToBadConnection","failureType","currentNode","head","nextNode","next","eventObject","detach","callback","errorMessage","cid","cancelPendingResponse","openAbort","_cancelBatching","closeMessage","handler","procedure","decode","encode","object","transmitObject","_handleEventAckTimeout","eventNode","_processOutboundEvent","expectResponse","promise","Promise","resolve","reject","Item","append","send","transmitPublish","pubData","_decorateChannelName","invokePublish","_triggerChannelSubscribe","subscriptionOptions","oldChannelState","newChannelState","_triggerChannelSubscribeFail","meetsAuthRequirements","waitForAuth","hasChannel","_cancelPendingSubscribeCallback","_pendingSubscriptionCid","decoratedChannelName","indexOf","replace","startBatch","flushBatch","cancelBatch","setInterval","startBatching","clearInterval","stopBatching","cancelBatching","_trySubscribe","noTimeout","invokeRaw","subscribe","sanitizedOptions","priority","undefined","channelIterable","setAsPending","_tryUnsubscribe","unsubscribe","receiver","receiverName","stream","closeReceiver","closeAllReceivers","closeAll","killReceiver","kill","killAllReceivers","killAll","killReceiverConsumer","consumerId","killConsumer","getReceiverConsumerStats","getConsumerStats","getReceiverConsumerStatsList","getConsumerStatsList","getAllReceiversConsumerStatsList","getConsumerStatsListAll","getReceiverBackpressure","getBackpressureAll","getReceiverConsumerBackpressure","getConsumerBackpressure","hasReceiverConsumer","hasConsumer","hasAnyReceiverConsumer","hasConsumerAll","procedureName","closeProcedure","closeAllProcedures","killProcedure","killAllProcedures","killProcedureConsumer","getProcedureConsumerStats","getProcedureConsumerStatsList","getAllProceduresConsumerStatsList","getProcedureBackpressure","getProcedureConsumerBackpressure","hasProcedureConsumer","hasAnyProcedureConsumer","currentChannel","closeChannel","channelCloseOutput","channelCloseAllListeners","closeAllChannelOutputs","closeAllChannelListeners","closeAllChannels","killChannel","channelKillOutput","channelKillAllListeners","killAllChannelOutputs","killAllChannelListeners","killAllChannels","killChannelOutputConsumer","killChannelListenerConsumer","getChannelOutputConsumerStats","getChannelListenerConsumerStats","getAllChannelOutputsConsumerStatsList","getAllChannelListenersConsumerStatsList","getChannelBackpressure","channelGetOutputBackpressure","channelGetAllListenersBackpressure","getAllChannelOutputsBackpressure","getAllChannelListenersBackpressure","getChannelListenerConsumerBackpressure","getChannelOutputConsumerBackpressure","hasAnyChannelOutputConsumer","hasAnyChannelListenerConsumer","getChannelState","getChannelOptions","_getAllChannelStreamNames","streamNamesLookup","filter","stats","reduce","accumulator","channelCloseListener","eventName","listenerStreams","streamName","channelKillListener","channelGetOutputConsumerStatsList","channelGetListenerConsumerStatsList","channelGetAllListenersConsumerStatsList","map","statsList","channelGetListenerBackpressure","listenerStreamBackpressures","concat","channelHasOutputConsumer","channelHasListenerConsumer","channelHasAnyListenerConsumer","some","subscriptions","includePending","subs","pendingChannels","sort","a","b","ap","bp","module","exports"],"sources":["C:/Users/bryan/Desktop/Projects/my-app/node_modules/socketcluster-client/lib/clientsocket.js"],"sourcesContent":["const StreamDemux = require('stream-demux');\r\nconst AsyncStreamEmitter = require('async-stream-emitter');\r\nconst AGChannel = require('ag-channel');\r\nconst AuthEngine = require('./auth');\r\nconst formatter = require('sc-formatter');\r\nconst AGTransport = require('./transport');\r\nconst LinkedList = require('linked-list');\r\nconst cloneDeep = require('clone-deep');\r\nconst Buffer = require('buffer/').Buffer;\r\nconst wait = require('./wait');\r\n\r\nconst scErrors = require('sc-errors');\r\nconst InvalidArgumentsError = scErrors.InvalidArgumentsError;\r\nconst InvalidMessageError = scErrors.InvalidMessageError;\r\nconst SocketProtocolError = scErrors.SocketProtocolError;\r\nconst TimeoutError = scErrors.TimeoutError;\r\nconst BadConnectionError = scErrors.BadConnectionError;\r\n\r\nfunction AGClientSocket(socketOptions) {\r\n  AsyncStreamEmitter.call(this);\r\n\r\n  let defaultOptions = {\r\n    path: '/socketcluster/',\r\n    secure: false,\r\n    protocolScheme: null,\r\n    socketPath: null,\r\n    autoConnect: true,\r\n    autoReconnect: true,\r\n    autoSubscribeOnConnect: true,\r\n    connectTimeout: 20000,\r\n    ackTimeout: 10000,\r\n    timestampRequests: false,\r\n    timestampParam: 't',\r\n    binaryType: 'arraybuffer',\r\n    batchOnHandshake: false,\r\n    batchOnHandshakeDuration: 100,\r\n    batchInterval: 50,\r\n    protocolVersion: 2,\r\n    wsOptions: {},\r\n    cloneData: false\r\n  };\r\n  let opts = Object.assign(defaultOptions, socketOptions);\r\n\r\n  if (opts.authTokenName == null) {\r\n    opts.authTokenName = this._generateAuthTokenNameFromURI(opts);\r\n  }\r\n\r\n  this.id = null;\r\n  this.version = opts.version || null;\r\n  this.protocolVersion = opts.protocolVersion;\r\n  this.state = this.CLOSED;\r\n  this.authState = this.UNAUTHENTICATED;\r\n  this.signedAuthToken = null;\r\n  this.authToken = null;\r\n  this.pendingReconnect = false;\r\n  this.pendingReconnectTimeout = null;\r\n  this.preparingPendingSubscriptions = false;\r\n  this.clientId = opts.clientId;\r\n  this.wsOptions = opts.wsOptions;\r\n\r\n  this.connectTimeout = opts.connectTimeout;\r\n  this.ackTimeout = opts.ackTimeout;\r\n  this.channelPrefix = opts.channelPrefix || null;\r\n  this.authTokenName = opts.authTokenName;\r\n\r\n  // pingTimeout will be connectTimeout at the start, but it will\r\n  // be updated with values provided by the 'connect' event\r\n  opts.pingTimeout = opts.connectTimeout;\r\n  this.pingTimeout = opts.pingTimeout;\r\n  this.pingTimeoutDisabled = !!opts.pingTimeoutDisabled;\r\n\r\n  let maxTimeout = Math.pow(2, 31) - 1;\r\n\r\n  let verifyDuration = (propertyName) => {\r\n    if (this[propertyName] > maxTimeout) {\r\n      throw new InvalidArgumentsError(\r\n        `The ${propertyName} value provided exceeded the maximum amount allowed`\r\n      );\r\n    }\r\n  };\r\n\r\n  verifyDuration('connectTimeout');\r\n  verifyDuration('ackTimeout');\r\n  verifyDuration('pingTimeout');\r\n\r\n  this.connectAttempts = 0;\r\n\r\n  this.isBatching = false;\r\n  this.batchOnHandshake = opts.batchOnHandshake;\r\n  this.batchOnHandshakeDuration = opts.batchOnHandshakeDuration;\r\n\r\n  this._batchingIntervalId = null;\r\n  this._outboundBuffer = new LinkedList();\r\n  this._channelMap = {};\r\n\r\n  this._channelEventDemux = new StreamDemux();\r\n  this._channelDataDemux = new StreamDemux();\r\n\r\n  this._receiverDemux = new StreamDemux();\r\n  this._procedureDemux = new StreamDemux();\r\n\r\n  this.options = opts;\r\n\r\n  this._cid = 1;\r\n\r\n  this.options.callIdGenerator = () => {\r\n    return this._cid++;\r\n  };\r\n\r\n  if (this.options.autoReconnect) {\r\n    if (this.options.autoReconnectOptions == null) {\r\n      this.options.autoReconnectOptions = {};\r\n    }\r\n\r\n    // Add properties to the this.options.autoReconnectOptions object.\r\n    // We assign the reference to a reconnectOptions variable to avoid repetition.\r\n    let reconnectOptions = this.options.autoReconnectOptions;\r\n    if (reconnectOptions.initialDelay == null) {\r\n      reconnectOptions.initialDelay = 10000;\r\n    }\r\n    if (reconnectOptions.randomness == null) {\r\n      reconnectOptions.randomness = 10000;\r\n    }\r\n    if (reconnectOptions.multiplier == null) {\r\n      reconnectOptions.multiplier = 1.5;\r\n    }\r\n    if (reconnectOptions.maxDelay == null) {\r\n      reconnectOptions.maxDelay = 60000;\r\n    }\r\n  }\r\n\r\n  if (this.options.subscriptionRetryOptions == null) {\r\n    this.options.subscriptionRetryOptions = {};\r\n  }\r\n\r\n  if (this.options.authEngine) {\r\n    this.auth = this.options.authEngine;\r\n  } else {\r\n    this.auth = new AuthEngine();\r\n  }\r\n\r\n  if (this.options.codecEngine) {\r\n    this.codec = this.options.codecEngine;\r\n  } else {\r\n    // Default codec engine\r\n    this.codec = formatter;\r\n  }\r\n\r\n  if (this.options.protocol) {\r\n    let protocolOptionError = new InvalidArgumentsError(\r\n      'The protocol option does not affect socketcluster-client - ' +\r\n      'If you want to utilize SSL/TLS, use the secure option instead'\r\n    );\r\n    this._onError(protocolOptionError);\r\n  }\r\n\r\n  this.options.query = opts.query || {};\r\n  if (typeof this.options.query === 'string') {\r\n    let searchParams = new URLSearchParams(this.options.query);\r\n    let queryObject = {};\r\n    for (let [key, value] of searchParams.entries()) {\r\n      let currentValue = queryObject[key];\r\n      if (currentValue == null) {\r\n        queryObject[key] = value;\r\n      } else {\r\n        if (!Array.isArray(currentValue)) {\r\n          queryObject[key] = [currentValue];\r\n        }\r\n        queryObject[key].push(value);\r\n      }\r\n    }\r\n    this.options.query = queryObject;\r\n  }\r\n\r\n  if (this.options.autoConnect) {\r\n    this.connect();\r\n  }\r\n}\r\n\r\nAGClientSocket.prototype = Object.create(AsyncStreamEmitter.prototype);\r\n\r\nAGClientSocket.CONNECTING = AGClientSocket.prototype.CONNECTING = AGTransport.prototype.CONNECTING;\r\nAGClientSocket.OPEN = AGClientSocket.prototype.OPEN = AGTransport.prototype.OPEN;\r\nAGClientSocket.CLOSED = AGClientSocket.prototype.CLOSED = AGTransport.prototype.CLOSED;\r\n\r\nAGClientSocket.AUTHENTICATED = AGClientSocket.prototype.AUTHENTICATED = 'authenticated';\r\nAGClientSocket.UNAUTHENTICATED = AGClientSocket.prototype.UNAUTHENTICATED = 'unauthenticated';\r\n\r\nAGClientSocket.SUBSCRIBED = AGClientSocket.prototype.SUBSCRIBED = AGChannel.SUBSCRIBED;\r\nAGClientSocket.PENDING = AGClientSocket.prototype.PENDING = AGChannel.PENDING;\r\nAGClientSocket.UNSUBSCRIBED = AGClientSocket.prototype.UNSUBSCRIBED = AGChannel.UNSUBSCRIBED;\r\n\r\nAGClientSocket.ignoreStatuses = scErrors.socketProtocolIgnoreStatuses;\r\nAGClientSocket.errorStatuses = scErrors.socketProtocolErrorStatuses;\r\n\r\nObject.defineProperty(AGClientSocket.prototype, 'isBufferingBatch', {\r\n  get: function () {\r\n    return this.transport.isBufferingBatch;\r\n  }\r\n});\r\n\r\nAGClientSocket.prototype.uri = function () {\r\n  return AGTransport.computeURI(this.options);\r\n};\r\n\r\nAGClientSocket.prototype.getBackpressure = function () {\r\n  return Math.max(\r\n    this.getAllListenersBackpressure(),\r\n    this.getAllReceiversBackpressure(),\r\n    this.getAllProceduresBackpressure(),\r\n    this.getAllChannelsBackpressure()\r\n  );\r\n};\r\n\r\nAGClientSocket.prototype._generateAuthTokenNameFromURI = function (options) {\r\n  let authHostString = options.host ? `.${options.host}` : `.${options.hostname || 'localhost'}${options.port ? `:${options.port}` : ''}`;\r\n  return `socketcluster.authToken${authHostString}`;\r\n}\r\n\r\nAGClientSocket.prototype._setAuthToken = function (data) {\r\n  this._changeToAuthenticatedState(data.token);\r\n\r\n  (async () => {\r\n    try {\r\n      await this.auth.saveToken(this.authTokenName, data.token, {});\r\n    } catch (err) {\r\n      this._onError(err);\r\n    }\r\n  })();\r\n};\r\n\r\nAGClientSocket.prototype._removeAuthToken = function (data) {\r\n  (async () => {\r\n    let oldAuthToken;\r\n    try {\r\n      oldAuthToken = await this.auth.removeToken(this.authTokenName);\r\n    } catch (err) {\r\n      // Non-fatal error - Do not close the connection\r\n      this._onError(err);\r\n      return;\r\n    }\r\n    this.emit('removeAuthToken', {oldAuthToken});\r\n  })();\r\n\r\n  this._changeToUnauthenticatedStateAndClearTokens();\r\n};\r\n\r\nAGClientSocket.prototype._privateDataHandlerMap = {\r\n  '#publish': function (data) {\r\n    if (typeof data.channel !== 'string') return;\r\n    let undecoratedChannelName = this._undecorateChannelName(data.channel);\r\n    let isSubscribed = this.isSubscribed(undecoratedChannelName, true);\r\n\r\n    if (isSubscribed) {\r\n      this._channelDataDemux.write(undecoratedChannelName, data.data);\r\n    }\r\n  },\r\n  '#kickOut': function (data) {\r\n    if (typeof data.channel !== 'string') return;\r\n    let undecoratedChannelName = this._undecorateChannelName(data.channel);\r\n    let channel = this._channelMap[undecoratedChannelName];\r\n    if (channel) {\r\n      this.emit('kickOut', {\r\n        channel: undecoratedChannelName,\r\n        message: data.message\r\n      });\r\n      this._channelEventDemux.write(`${undecoratedChannelName}/kickOut`, {message: data.message});\r\n      this._triggerChannelUnsubscribe(channel);\r\n    }\r\n  },\r\n  '#setAuthToken': function (data) {\r\n    if (data) {\r\n      this._setAuthToken(data);\r\n    }\r\n  },\r\n  '#removeAuthToken': function (data) {\r\n    this._removeAuthToken(data);\r\n  }\r\n};\r\n\r\nAGClientSocket.prototype._privateRPCHandlerMap = {\r\n  '#setAuthToken': function (data, request) {\r\n    if (data) {\r\n      this._setAuthToken(data);\r\n\r\n      request.end();\r\n    } else {\r\n      let error = new InvalidMessageError('No token data provided by #setAuthToken event');\r\n      delete error.stack;\r\n      request.error(error);\r\n    }\r\n  },\r\n  '#removeAuthToken': function (data, request) {\r\n    this._removeAuthToken(data);\r\n    request.end();\r\n  }\r\n};\r\n\r\nAGClientSocket.prototype.getState = function () {\r\n  return this.state;\r\n};\r\n\r\nAGClientSocket.prototype.getBytesReceived = function () {\r\n  return this.transport.getBytesReceived();\r\n};\r\n\r\nAGClientSocket.prototype.deauthenticate = async function () {\r\n  (async () => {\r\n    let oldAuthToken;\r\n    try {\r\n      oldAuthToken = await this.auth.removeToken(this.authTokenName);\r\n    } catch (err) {\r\n      this._onError(err);\r\n      return;\r\n    }\r\n    this.emit('removeAuthToken', {oldAuthToken});\r\n  })();\r\n\r\n  if (this.state !== this.CLOSED) {\r\n    this.transmit('#removeAuthToken');\r\n  }\r\n  this._changeToUnauthenticatedStateAndClearTokens();\r\n  await wait(0);\r\n};\r\n\r\nAGClientSocket.prototype.connect = function (socketOptions) {\r\n  if (socketOptions) {\r\n    if (this.state !== this.CLOSED) {\r\n      this.disconnect(\r\n        1000,\r\n        'Socket was disconnected by the client to initiate a new connection'\r\n      );\r\n    }\r\n    this.options = {\r\n      ...this.options,\r\n      ...socketOptions\r\n    };\r\n    if (this.options.authTokenName == null) {\r\n      this.options.authTokenName = this._generateAuthTokenNameFromURI(this.options);\r\n    }\r\n  }\r\n  if (this.state === this.CLOSED) {\r\n    this.pendingReconnect = false;\r\n    this.pendingReconnectTimeout = null;\r\n    clearTimeout(this._reconnectTimeoutRef);\r\n\r\n    this.state = this.CONNECTING;\r\n    this.emit('connecting', {});\r\n\r\n    if (this.transport) {\r\n      this.transport.clearAllListeners();\r\n    }\r\n\r\n    let transportHandlers = {\r\n      onOpen: (value) => {\r\n        this.state = this.OPEN;\r\n        this._onOpen(value);\r\n      },\r\n      onOpenAbort: (value) => {\r\n        if (this.state !== this.CLOSED) {\r\n          this.state = this.CLOSED;\r\n          this._destroy(value.code, value.reason, true);\r\n        }\r\n      },\r\n      onClose: (value) => {\r\n        if (this.state !== this.CLOSED) {\r\n          this.state = this.CLOSED;\r\n          this._destroy(value.code, value.reason);\r\n        }\r\n      },\r\n      onEvent: (value) => {\r\n        this.emit(value.event, value.data);\r\n      },\r\n      onError: (value) => {\r\n        this._onError(value.error);\r\n      },\r\n      onInboundInvoke: (value) => {\r\n        this._onInboundInvoke(value);\r\n      },\r\n      onInboundTransmit: (value) => {\r\n        this._onInboundTransmit(value.event, value.data);\r\n      }\r\n    };\r\n\r\n    this.transport = new AGTransport(this.auth, this.codec, this.options, this.wsOptions, transportHandlers);\r\n  }\r\n};\r\n\r\nAGClientSocket.prototype.reconnect = function (code, reason) {\r\n  this.disconnect(code, reason);\r\n  this.connect();\r\n};\r\n\r\nAGClientSocket.prototype.disconnect = function (code, reason) {\r\n  code = code || 1000;\r\n\r\n  if (typeof code !== 'number') {\r\n    throw new InvalidArgumentsError('If specified, the code argument must be a number');\r\n  }\r\n\r\n  let isConnecting = this.state === this.CONNECTING;\r\n  if (isConnecting || this.state === this.OPEN) {\r\n    this.state = this.CLOSED;\r\n    this._destroy(code, reason, isConnecting);\r\n    this.transport.close(code, reason);\r\n  } else {\r\n    this.pendingReconnect = false;\r\n    this.pendingReconnectTimeout = null;\r\n    clearTimeout(this._reconnectTimeoutRef);\r\n  }\r\n};\r\n\r\nAGClientSocket.prototype._changeToUnauthenticatedStateAndClearTokens = function () {\r\n  if (this.authState !== this.UNAUTHENTICATED) {\r\n    let oldAuthState = this.authState;\r\n    let oldAuthToken = this.authToken;\r\n    let oldSignedAuthToken = this.signedAuthToken;\r\n    this.authState = this.UNAUTHENTICATED;\r\n    this.signedAuthToken = null;\r\n    this.authToken = null;\r\n\r\n    let stateChangeData = {\r\n      oldAuthState,\r\n      newAuthState: this.authState\r\n    };\r\n    this.emit('authStateChange', stateChangeData);\r\n    this.emit('deauthenticate', {oldSignedAuthToken, oldAuthToken});\r\n  }\r\n};\r\n\r\nAGClientSocket.prototype._changeToAuthenticatedState = function (signedAuthToken) {\r\n  this.signedAuthToken = signedAuthToken;\r\n  this.authToken = this._extractAuthTokenData(signedAuthToken);\r\n\r\n  if (this.authState !== this.AUTHENTICATED) {\r\n    let oldAuthState = this.authState;\r\n    this.authState = this.AUTHENTICATED;\r\n    let stateChangeData = {\r\n      oldAuthState,\r\n      newAuthState: this.authState,\r\n      signedAuthToken: signedAuthToken,\r\n      authToken: this.authToken\r\n    };\r\n    if (!this.preparingPendingSubscriptions) {\r\n      this.processPendingSubscriptions();\r\n    }\r\n\r\n    this.emit('authStateChange', stateChangeData);\r\n  }\r\n  this.emit('authenticate', {signedAuthToken, authToken: this.authToken});\r\n};\r\n\r\nAGClientSocket.prototype.decodeBase64 = function (encodedString) {\r\n  return Buffer.from(encodedString, 'base64').toString('utf8');\r\n};\r\n\r\nAGClientSocket.prototype.encodeBase64 = function (decodedString) {\r\n  return Buffer.from(decodedString, 'utf8').toString('base64');\r\n};\r\n\r\nAGClientSocket.prototype._extractAuthTokenData = function (signedAuthToken) {\r\n  if (typeof signedAuthToken !== 'string') return null;\r\n  let tokenParts = signedAuthToken.split('.');\r\n  let encodedTokenData = tokenParts[1];\r\n  if (encodedTokenData != null) {\r\n    let tokenData = encodedTokenData;\r\n    try {\r\n      tokenData = this.decodeBase64(tokenData);\r\n      return JSON.parse(tokenData);\r\n    } catch (e) {\r\n      return tokenData;\r\n    }\r\n  }\r\n  return null;\r\n};\r\n\r\nAGClientSocket.prototype.getAuthToken = function () {\r\n  return this.authToken;\r\n};\r\n\r\nAGClientSocket.prototype.getSignedAuthToken = function () {\r\n  return this.signedAuthToken;\r\n};\r\n\r\n// Perform client-initiated authentication by providing an encrypted token string.\r\nAGClientSocket.prototype.authenticate = async function (signedAuthToken) {\r\n  let authStatus;\r\n\r\n  try {\r\n    authStatus = await this.invoke('#authenticate', signedAuthToken);\r\n  } catch (err) {\r\n    if (err.name !== 'BadConnectionError' && err.name !== 'TimeoutError') {\r\n      // In case of a bad/closed connection or a timeout, we maintain the last\r\n      // known auth state since those errors don't mean that the token is invalid.\r\n      this._changeToUnauthenticatedStateAndClearTokens();\r\n    }\r\n    await wait(0);\r\n    throw err;\r\n  }\r\n\r\n  if (authStatus && authStatus.isAuthenticated != null) {\r\n    // If authStatus is correctly formatted (has an isAuthenticated property),\r\n    // then we will rehydrate the authError.\r\n    if (authStatus.authError) {\r\n      authStatus.authError = scErrors.hydrateError(authStatus.authError);\r\n    }\r\n  } else {\r\n    // Some errors like BadConnectionError and TimeoutError will not pass a valid\r\n    // authStatus object to the current function, so we need to create it ourselves.\r\n    authStatus = {\r\n      isAuthenticated: this.authState,\r\n      authError: null\r\n    };\r\n  }\r\n\r\n  if (authStatus.isAuthenticated) {\r\n    this._changeToAuthenticatedState(signedAuthToken);\r\n  } else {\r\n    this._changeToUnauthenticatedStateAndClearTokens();\r\n  }\r\n\r\n  (async () => {\r\n    try {\r\n      await this.auth.saveToken(this.authTokenName, signedAuthToken, {});\r\n    } catch (err) {\r\n      this._onError(err);\r\n    }\r\n  })();\r\n\r\n  await wait(0);\r\n  return authStatus;\r\n};\r\n\r\nAGClientSocket.prototype._tryReconnect = function (initialDelay) {\r\n  let exponent = this.connectAttempts++;\r\n  let reconnectOptions = this.options.autoReconnectOptions;\r\n  let timeout;\r\n\r\n  if (initialDelay == null || exponent > 0) {\r\n    let initialTimeout = Math.round(reconnectOptions.initialDelay + (reconnectOptions.randomness || 0) * Math.random());\r\n\r\n    timeout = Math.round(initialTimeout * Math.pow(reconnectOptions.multiplier, exponent));\r\n  } else {\r\n    timeout = initialDelay;\r\n  }\r\n\r\n  if (timeout > reconnectOptions.maxDelay) {\r\n    timeout = reconnectOptions.maxDelay;\r\n  }\r\n\r\n  clearTimeout(this._reconnectTimeoutRef);\r\n\r\n  this.pendingReconnect = true;\r\n  this.pendingReconnectTimeout = timeout;\r\n  this._reconnectTimeoutRef = setTimeout(() => {\r\n    this.connect();\r\n  }, timeout);\r\n};\r\n\r\nAGClientSocket.prototype._onOpen = function (status) {\r\n  if (this.isBatching) {\r\n    this._startBatching();\r\n  } else if (this.batchOnHandshake) {\r\n    this._startBatching();\r\n    setTimeout(() => {\r\n      if (!this.isBatching) {\r\n        this._stopBatching();\r\n      }\r\n    }, this.batchOnHandshakeDuration);\r\n  }\r\n  this.preparingPendingSubscriptions = true;\r\n\r\n  if (status) {\r\n    this.id = status.id;\r\n    this.pingTimeout = status.pingTimeout;\r\n    if (status.isAuthenticated) {\r\n      this._changeToAuthenticatedState(status.authToken);\r\n    } else {\r\n      this._changeToUnauthenticatedStateAndClearTokens();\r\n    }\r\n  } else {\r\n    // This can happen if auth.loadToken (in transport.js) fails with\r\n    // an error - This means that the signedAuthToken cannot be loaded by\r\n    // the auth engine and therefore, we need to unauthenticate the client.\r\n    this._changeToUnauthenticatedStateAndClearTokens();\r\n  }\r\n\r\n  this.connectAttempts = 0;\r\n\r\n  if (this.options.autoSubscribeOnConnect) {\r\n    this.processPendingSubscriptions();\r\n  }\r\n\r\n  // If the user invokes the callback while in autoSubscribeOnConnect mode, it\r\n  // won't break anything.\r\n  this.emit('connect', {\r\n    ...status,\r\n    processPendingSubscriptions: () => {\r\n      this.processPendingSubscriptions();\r\n    }\r\n  });\r\n\r\n  if (this.state === this.OPEN) {\r\n    this._flushOutboundBuffer();\r\n  }\r\n};\r\n\r\nAGClientSocket.prototype._onError = function (error) {\r\n  this.emit('error', {error});\r\n};\r\n\r\nAGClientSocket.prototype._suspendSubscriptions = function () {\r\n  Object.keys(this._channelMap).forEach((channelName) => {\r\n    let channel = this._channelMap[channelName];\r\n    this._triggerChannelUnsubscribe(channel, true);\r\n  });\r\n};\r\n\r\nAGClientSocket.prototype._abortAllPendingEventsDueToBadConnection = function (failureType) {\r\n  let currentNode = this._outboundBuffer.head;\r\n  let nextNode;\r\n\r\n  while (currentNode) {\r\n    nextNode = currentNode.next;\r\n    let eventObject = currentNode.data;\r\n    clearTimeout(eventObject.timeout);\r\n    delete eventObject.timeout;\r\n    currentNode.detach();\r\n    currentNode = nextNode;\r\n\r\n    let callback = eventObject.callback;\r\n\r\n    if (callback) {\r\n      delete eventObject.callback;\r\n      let errorMessage = `Event ${eventObject.event} was aborted due to a bad connection`;\r\n      let error = new BadConnectionError(errorMessage, failureType);\r\n\r\n      callback.call(eventObject, error, eventObject);\r\n    }\r\n    // Cleanup any pending response callback in the transport layer too.\r\n    if (eventObject.cid) {\r\n      this.transport.cancelPendingResponse(eventObject.cid);\r\n    }\r\n  }\r\n};\r\n\r\nAGClientSocket.prototype._destroy = function (code, reason, openAbort) {\r\n  this.id = null;\r\n  this._cancelBatching();\r\n\r\n  if (this.transport) {\r\n    this.transport.clearAllListeners();\r\n  }\r\n\r\n  this.pendingReconnect = false;\r\n  this.pendingReconnectTimeout = null;\r\n  clearTimeout(this._reconnectTimeoutRef);\r\n\r\n  this._suspendSubscriptions();\r\n\r\n  if (openAbort) {\r\n    this.emit('connectAbort', {code, reason});\r\n  } else {\r\n    this.emit('disconnect', {code, reason});\r\n  }\r\n  this.emit('close', {code, reason});\r\n\r\n  if (!AGClientSocket.ignoreStatuses[code]) {\r\n    let closeMessage;\r\n    if (typeof reason === 'string') {\r\n      closeMessage = 'Socket connection closed with status code ' + code + ' and reason: ' + reason;\r\n    } else {\r\n      closeMessage = 'Socket connection closed with status code ' + code;\r\n    }\r\n    let err = new SocketProtocolError(AGClientSocket.errorStatuses[code] || closeMessage, code);\r\n    this._onError(err);\r\n  }\r\n\r\n  this._abortAllPendingEventsDueToBadConnection(openAbort ? 'connectAbort' : 'disconnect');\r\n\r\n  // Try to reconnect\r\n  // on server ping timeout (4000)\r\n  // or on client pong timeout (4001)\r\n  // or on close without status (1005)\r\n  // or on handshake failure (4003)\r\n  // or on handshake rejection (4008)\r\n  // or on socket hung up (1006)\r\n  if (this.options.autoReconnect) {\r\n    if (code === 4000 || code === 4001 || code === 1005) {\r\n      // If there is a ping or pong timeout or socket closes without\r\n      // status, don't wait before trying to reconnect - These could happen\r\n      // if the client wakes up after a period of inactivity and in this case we\r\n      // want to re-establish the connection as soon as possible.\r\n      this._tryReconnect(0);\r\n\r\n      // Codes 4500 and above will be treated as permanent disconnects.\r\n      // Socket will not try to auto-reconnect.\r\n    } else if (code !== 1000 && code < 4500) {\r\n      this._tryReconnect();\r\n    }\r\n  }\r\n};\r\n\r\nAGClientSocket.prototype._onInboundTransmit = function (event, data) {\r\n  let handler = this._privateDataHandlerMap[event];\r\n  if (handler) {\r\n    handler.call(this, data || {});\r\n  } else {\r\n    this._receiverDemux.write(event, data);\r\n  }\r\n};\r\n\r\nAGClientSocket.prototype._onInboundInvoke = function (request) {\r\n  let {procedure, data} = request;\r\n  let handler = this._privateRPCHandlerMap[procedure];\r\n  if (handler) {\r\n    handler.call(this, data, request);\r\n  } else {\r\n    this._procedureDemux.write(procedure, request);\r\n  }\r\n};\r\n\r\nAGClientSocket.prototype.decode = function (message) {\r\n  return this.transport.decode(message);\r\n};\r\n\r\nAGClientSocket.prototype.encode = function (object) {\r\n  return this.transport.encode(object);\r\n};\r\n\r\nAGClientSocket.prototype._flushOutboundBuffer = function () {\r\n  let currentNode = this._outboundBuffer.head;\r\n  let nextNode;\r\n\r\n  while (currentNode) {\r\n    nextNode = currentNode.next;\r\n    let eventObject = currentNode.data;\r\n    currentNode.detach();\r\n    this.transport.transmitObject(eventObject);\r\n    currentNode = nextNode;\r\n  }\r\n};\r\n\r\nAGClientSocket.prototype._handleEventAckTimeout = function (eventObject, eventNode) {\r\n  if (eventNode) {\r\n    eventNode.detach();\r\n  }\r\n  delete eventObject.timeout;\r\n\r\n  let callback = eventObject.callback;\r\n  if (callback) {\r\n    delete eventObject.callback;\r\n    let error = new TimeoutError(`Event response for ${eventObject.event} event timed out`);\r\n    callback.call(eventObject, error, eventObject);\r\n  }\r\n  // Cleanup any pending response callback in the transport layer too.\r\n  if (eventObject.cid) {\r\n    this.transport.cancelPendingResponse(eventObject.cid);\r\n  }\r\n};\r\n\r\nAGClientSocket.prototype._processOutboundEvent = function (event, data, options, expectResponse) {\r\n  options = options || {};\r\n\r\n  if (this.state === this.CLOSED) {\r\n    this.connect();\r\n  }\r\n  let eventObject = {\r\n    event\r\n  };\r\n\r\n  let promise;\r\n\r\n  if (expectResponse) {\r\n    promise = new Promise((resolve, reject) => {\r\n      eventObject.callback = (err, data) => {\r\n        if (err) {\r\n          reject(err);\r\n          return;\r\n        }\r\n        resolve(data);\r\n      };\r\n    });\r\n  } else {\r\n    promise = Promise.resolve();\r\n  }\r\n\r\n  let eventNode = new LinkedList.Item();\r\n\r\n  if (this.options.cloneData) {\r\n    eventObject.data = cloneDeep(data);\r\n  } else {\r\n    eventObject.data = data;\r\n  }\r\n  eventNode.data = eventObject;\r\n\r\n  let ackTimeout = options.ackTimeout == null ? this.ackTimeout : options.ackTimeout;\r\n\r\n  eventObject.timeout = setTimeout(() => {\r\n    this._handleEventAckTimeout(eventObject, eventNode);\r\n  }, ackTimeout);\r\n\r\n  this._outboundBuffer.append(eventNode);\r\n  if (this.state === this.OPEN) {\r\n    this._flushOutboundBuffer();\r\n  }\r\n  return promise;\r\n};\r\n\r\nAGClientSocket.prototype.send = function (data) {\r\n  this.transport.send(data);\r\n};\r\n\r\nAGClientSocket.prototype.transmit = function (event, data, options) {\r\n  return this._processOutboundEvent(event, data, options);\r\n};\r\n\r\nAGClientSocket.prototype.invoke = function (event, data, options) {\r\n  return this._processOutboundEvent(event, data, options, true);\r\n};\r\n\r\nAGClientSocket.prototype.transmitPublish = function (channelName, data) {\r\n  let pubData = {\r\n    channel: this._decorateChannelName(channelName),\r\n    data\r\n  };\r\n  return this.transmit('#publish', pubData);\r\n};\r\n\r\nAGClientSocket.prototype.invokePublish = function (channelName, data) {\r\n  let pubData = {\r\n    channel: this._decorateChannelName(channelName),\r\n    data\r\n  };\r\n  return this.invoke('#publish', pubData);\r\n};\r\n\r\nAGClientSocket.prototype._triggerChannelSubscribe = function (channel, subscriptionOptions) {\r\n  let channelName = channel.name;\r\n\r\n  if (channel.state !== AGChannel.SUBSCRIBED) {\r\n    let oldChannelState = channel.state;\r\n    channel.state = AGChannel.SUBSCRIBED;\r\n\r\n    let stateChangeData = {\r\n      oldChannelState,\r\n      newChannelState: channel.state,\r\n      subscriptionOptions\r\n    };\r\n    this._channelEventDemux.write(`${channelName}/subscribeStateChange`, stateChangeData);\r\n    this._channelEventDemux.write(`${channelName}/subscribe`, {\r\n      subscriptionOptions\r\n    });\r\n    this.emit('subscribeStateChange', {\r\n      channel: channelName,\r\n      ...stateChangeData\r\n    });\r\n    this.emit('subscribe', {\r\n      channel: channelName,\r\n      subscriptionOptions\r\n    });\r\n  }\r\n};\r\n\r\nAGClientSocket.prototype._triggerChannelSubscribeFail = function (err, channel, subscriptionOptions) {\r\n  let channelName = channel.name;\r\n  let meetsAuthRequirements = !channel.options.waitForAuth || this.authState === this.AUTHENTICATED;\r\n  let hasChannel = !!this._channelMap[channelName];\r\n\r\n  if (hasChannel && meetsAuthRequirements) {\r\n    delete this._channelMap[channelName];\r\n\r\n    this._channelEventDemux.write(`${channelName}/subscribeFail`, {\r\n      error: err,\r\n      subscriptionOptions\r\n    });\r\n    this.emit('subscribeFail', {\r\n      error: err,\r\n      channel: channelName,\r\n      subscriptionOptions: subscriptionOptions\r\n    });\r\n  }\r\n};\r\n\r\n// Cancel any pending subscribe callback\r\nAGClientSocket.prototype._cancelPendingSubscribeCallback = function (channel) {\r\n  if (channel._pendingSubscriptionCid != null) {\r\n    this.transport.cancelPendingResponse(channel._pendingSubscriptionCid);\r\n    delete channel._pendingSubscriptionCid;\r\n  }\r\n};\r\n\r\nAGClientSocket.prototype._decorateChannelName = function (channelName) {\r\n  if (this.channelPrefix) {\r\n    channelName = this.channelPrefix + channelName;\r\n  }\r\n  return channelName;\r\n};\r\n\r\nAGClientSocket.prototype._undecorateChannelName = function (decoratedChannelName) {\r\n  if (this.channelPrefix && decoratedChannelName.indexOf(this.channelPrefix) === 0) {\r\n    return decoratedChannelName.replace(this.channelPrefix, '');\r\n  }\r\n  return decoratedChannelName;\r\n};\r\n\r\nAGClientSocket.prototype.startBatch = function () {\r\n  this.transport.startBatch();\r\n};\r\n\r\nAGClientSocket.prototype.flushBatch = function () {\r\n  this.transport.flushBatch();\r\n};\r\n\r\nAGClientSocket.prototype.cancelBatch = function () {\r\n  this.transport.cancelBatch();\r\n};\r\n\r\nAGClientSocket.prototype._startBatching = function () {\r\n  if (this._batchingIntervalId != null) {\r\n    return;\r\n  }\r\n  this.startBatch();\r\n  this._batchingIntervalId = setInterval(() => {\r\n    this.flushBatch();\r\n    this.startBatch();\r\n  }, this.options.batchInterval);\r\n};\r\n\r\nAGClientSocket.prototype.startBatching = function () {\r\n  this.isBatching = true;\r\n  this._startBatching();\r\n};\r\n\r\nAGClientSocket.prototype._stopBatching = function () {\r\n  if (this._batchingIntervalId != null) {\r\n    clearInterval(this._batchingIntervalId);\r\n  }\r\n  this._batchingIntervalId = null;\r\n  this.flushBatch();\r\n};\r\n\r\nAGClientSocket.prototype.stopBatching = function () {\r\n  this.isBatching = false;\r\n  this._stopBatching();\r\n};\r\n\r\nAGClientSocket.prototype._cancelBatching = function () {\r\n  if (this._batchingIntervalId != null) {\r\n    clearInterval(this._batchingIntervalId);\r\n  }\r\n  this._batchingIntervalId = null;\r\n  this.cancelBatch();\r\n};\r\n\r\nAGClientSocket.prototype.cancelBatching = function () {\r\n  this.isBatching = false;\r\n  this._cancelBatching();\r\n};\r\n\r\nAGClientSocket.prototype._trySubscribe = function (channel) {\r\n  let meetsAuthRequirements = !channel.options.waitForAuth || this.authState === this.AUTHENTICATED;\r\n\r\n  // We can only ever have one pending subscribe action at any given time on a channel\r\n  if (\r\n    this.state === this.OPEN &&\r\n    !this.preparingPendingSubscriptions &&\r\n    channel._pendingSubscriptionCid == null &&\r\n    meetsAuthRequirements\r\n  ) {\r\n\r\n    let options = {\r\n      noTimeout: true\r\n    };\r\n\r\n    let subscriptionOptions = {};\r\n    if (channel.options.waitForAuth) {\r\n      options.waitForAuth = true;\r\n      subscriptionOptions.waitForAuth = options.waitForAuth;\r\n    }\r\n    if (channel.options.data) {\r\n      subscriptionOptions.data = channel.options.data;\r\n    }\r\n\r\n    channel._pendingSubscriptionCid = this.transport.invokeRaw(\r\n      '#subscribe',\r\n      {\r\n        channel: this._decorateChannelName(channel.name),\r\n        ...subscriptionOptions\r\n      },\r\n      options,\r\n      (err) => {\r\n        if (err) {\r\n          if (err.name === 'BadConnectionError') {\r\n            // In case of a failed connection, keep the subscription\r\n            // as pending; it will try again on reconnect.\r\n            return;\r\n          }\r\n          delete channel._pendingSubscriptionCid;\r\n          this._triggerChannelSubscribeFail(err, channel, subscriptionOptions);\r\n        } else {\r\n          delete channel._pendingSubscriptionCid;\r\n          this._triggerChannelSubscribe(channel, subscriptionOptions);\r\n        }\r\n      }\r\n    );\r\n    this.emit('subscribeRequest', {\r\n      channel: channel.name,\r\n      subscriptionOptions\r\n    });\r\n  }\r\n};\r\n\r\nAGClientSocket.prototype.subscribe = function (channelName, options) {\r\n  options = options || {};\r\n  let channel = this._channelMap[channelName];\r\n\r\n  let sanitizedOptions = {\r\n    waitForAuth: !!options.waitForAuth\r\n  };\r\n\r\n  if (options.priority != null) {\r\n    sanitizedOptions.priority = options.priority;\r\n  }\r\n  if (options.data !== undefined) {\r\n    sanitizedOptions.data = options.data;\r\n  }\r\n\r\n  if (!channel) {\r\n    channel = {\r\n      name: channelName,\r\n      state: AGChannel.PENDING,\r\n      options: sanitizedOptions\r\n    };\r\n    this._channelMap[channelName] = channel;\r\n    this._trySubscribe(channel);\r\n  } else if (options) {\r\n    channel.options = sanitizedOptions;\r\n  }\r\n\r\n  let channelIterable = new AGChannel(\r\n    channelName,\r\n    this,\r\n    this._channelEventDemux,\r\n    this._channelDataDemux\r\n  );\r\n\r\n  return channelIterable;\r\n};\r\n\r\nAGClientSocket.prototype._triggerChannelUnsubscribe = function (channel, setAsPending) {\r\n  let channelName = channel.name;\r\n\r\n  this._cancelPendingSubscribeCallback(channel);\r\n\r\n  if (channel.state === AGChannel.SUBSCRIBED) {\r\n    let stateChangeData = {\r\n      oldChannelState: channel.state,\r\n      newChannelState: setAsPending ? AGChannel.PENDING : AGChannel.UNSUBSCRIBED\r\n    };\r\n    this._channelEventDemux.write(`${channelName}/subscribeStateChange`, stateChangeData);\r\n    this._channelEventDemux.write(`${channelName}/unsubscribe`, {});\r\n    this.emit('subscribeStateChange', {\r\n      channel: channelName,\r\n      ...stateChangeData\r\n    });\r\n    this.emit('unsubscribe', {channel: channelName});\r\n  }\r\n\r\n  if (setAsPending) {\r\n    channel.state = AGChannel.PENDING;\r\n  } else {\r\n    delete this._channelMap[channelName];\r\n  }\r\n};\r\n\r\nAGClientSocket.prototype._tryUnsubscribe = function (channel) {\r\n  if (this.state === this.OPEN) {\r\n    let options = {\r\n      noTimeout: true\r\n    };\r\n    // If there is a pending subscribe action, cancel the callback\r\n    this._cancelPendingSubscribeCallback(channel);\r\n\r\n    // This operation cannot fail because the TCP protocol guarantees delivery\r\n    // so long as the connection remains open. If the connection closes,\r\n    // the server will automatically unsubscribe the client and thus complete\r\n    // the operation on the server side.\r\n    let decoratedChannelName = this._decorateChannelName(channel.name);\r\n    this.transport.transmit('#unsubscribe', decoratedChannelName, options);\r\n  }\r\n};\r\n\r\nAGClientSocket.prototype.unsubscribe = function (channelName) {\r\n  let channel = this._channelMap[channelName];\r\n\r\n  if (channel) {\r\n    this._triggerChannelUnsubscribe(channel);\r\n    this._tryUnsubscribe(channel);\r\n  }\r\n};\r\n\r\n// ---- Receiver logic ----\r\n\r\nAGClientSocket.prototype.receiver = function (receiverName) {\r\n  return this._receiverDemux.stream(receiverName);\r\n};\r\n\r\nAGClientSocket.prototype.closeReceiver = function (receiverName) {\r\n  this._receiverDemux.close(receiverName);\r\n};\r\n\r\nAGClientSocket.prototype.closeAllReceivers = function () {\r\n  this._receiverDemux.closeAll();\r\n};\r\n\r\nAGClientSocket.prototype.killReceiver = function (receiverName) {\r\n  this._receiverDemux.kill(receiverName);\r\n};\r\n\r\nAGClientSocket.prototype.killAllReceivers = function () {\r\n  this._receiverDemux.killAll();\r\n};\r\n\r\nAGClientSocket.prototype.killReceiverConsumer = function (consumerId) {\r\n  this._receiverDemux.killConsumer(consumerId);\r\n};\r\n\r\nAGClientSocket.prototype.getReceiverConsumerStats = function (consumerId) {\r\n  return this._receiverDemux.getConsumerStats(consumerId);\r\n};\r\n\r\nAGClientSocket.prototype.getReceiverConsumerStatsList = function (receiverName) {\r\n  return this._receiverDemux.getConsumerStatsList(receiverName);\r\n};\r\n\r\nAGClientSocket.prototype.getAllReceiversConsumerStatsList = function () {\r\n  return this._receiverDemux.getConsumerStatsListAll();\r\n};\r\n\r\nAGClientSocket.prototype.getReceiverBackpressure = function (receiverName) {\r\n  return this._receiverDemux.getBackpressure(receiverName);\r\n};\r\n\r\nAGClientSocket.prototype.getAllReceiversBackpressure = function () {\r\n  return this._receiverDemux.getBackpressureAll();\r\n};\r\n\r\nAGClientSocket.prototype.getReceiverConsumerBackpressure = function (consumerId) {\r\n  return this._receiverDemux.getConsumerBackpressure(consumerId);\r\n};\r\n\r\nAGClientSocket.prototype.hasReceiverConsumer = function (receiverName, consumerId) {\r\n  return this._receiverDemux.hasConsumer(receiverName, consumerId);\r\n};\r\n\r\nAGClientSocket.prototype.hasAnyReceiverConsumer = function (consumerId) {\r\n  return this._receiverDemux.hasConsumerAll(consumerId);\r\n};\r\n\r\n// ---- Procedure logic ----\r\n\r\nAGClientSocket.prototype.procedure = function (procedureName) {\r\n  return this._procedureDemux.stream(procedureName);\r\n};\r\n\r\nAGClientSocket.prototype.closeProcedure = function (procedureName) {\r\n  this._procedureDemux.close(procedureName);\r\n};\r\n\r\nAGClientSocket.prototype.closeAllProcedures = function () {\r\n  this._procedureDemux.closeAll();\r\n};\r\n\r\nAGClientSocket.prototype.killProcedure = function (procedureName) {\r\n  this._procedureDemux.kill(procedureName);\r\n};\r\n\r\nAGClientSocket.prototype.killAllProcedures = function () {\r\n  this._procedureDemux.killAll();\r\n};\r\n\r\nAGClientSocket.prototype.killProcedureConsumer = function (consumerId) {\r\n  this._procedureDemux.killConsumer(consumerId);\r\n};\r\n\r\nAGClientSocket.prototype.getProcedureConsumerStats = function (consumerId) {\r\n  return this._procedureDemux.getConsumerStats(consumerId);\r\n};\r\n\r\nAGClientSocket.prototype.getProcedureConsumerStatsList = function (procedureName) {\r\n  return this._procedureDemux.getConsumerStatsList(procedureName);\r\n};\r\n\r\nAGClientSocket.prototype.getAllProceduresConsumerStatsList = function () {\r\n  return this._procedureDemux.getConsumerStatsListAll();\r\n};\r\n\r\nAGClientSocket.prototype.getProcedureBackpressure = function (procedureName) {\r\n  return this._procedureDemux.getBackpressure(procedureName);\r\n};\r\n\r\nAGClientSocket.prototype.getAllProceduresBackpressure = function () {\r\n  return this._procedureDemux.getBackpressureAll();\r\n};\r\n\r\nAGClientSocket.prototype.getProcedureConsumerBackpressure = function (consumerId) {\r\n  return this._procedureDemux.getConsumerBackpressure(consumerId);\r\n};\r\n\r\nAGClientSocket.prototype.hasProcedureConsumer = function (procedureName, consumerId) {\r\n  return this._procedureDemux.hasConsumer(procedureName, consumerId);\r\n};\r\n\r\nAGClientSocket.prototype.hasAnyProcedureConsumer = function (consumerId) {\r\n  return this._procedureDemux.hasConsumerAll(consumerId);\r\n};\r\n\r\n// ---- Channel logic ----\r\n\r\nAGClientSocket.prototype.channel = function (channelName) {\r\n  let currentChannel = this._channelMap[channelName];\r\n\r\n  let channelIterable = new AGChannel(\r\n    channelName,\r\n    this,\r\n    this._channelEventDemux,\r\n    this._channelDataDemux\r\n  );\r\n\r\n  return channelIterable;\r\n};\r\n\r\nAGClientSocket.prototype.closeChannel = function (channelName) {\r\n  this.channelCloseOutput(channelName);\r\n  this.channelCloseAllListeners(channelName);\r\n};\r\n\r\nAGClientSocket.prototype.closeAllChannelOutputs = function () {\r\n  this._channelDataDemux.closeAll();\r\n};\r\n\r\nAGClientSocket.prototype.closeAllChannelListeners = function () {\r\n  this._channelEventDemux.closeAll();\r\n};\r\n\r\nAGClientSocket.prototype.closeAllChannels = function () {\r\n  this.closeAllChannelOutputs();\r\n  this.closeAllChannelListeners();\r\n};\r\n\r\nAGClientSocket.prototype.killChannel = function (channelName) {\r\n  this.channelKillOutput(channelName);\r\n  this.channelKillAllListeners(channelName);\r\n};\r\n\r\nAGClientSocket.prototype.killAllChannelOutputs = function () {\r\n  this._channelDataDemux.killAll();\r\n};\r\n\r\nAGClientSocket.prototype.killAllChannelListeners = function () {\r\n  this._channelEventDemux.killAll();\r\n};\r\n\r\nAGClientSocket.prototype.killAllChannels = function () {\r\n  this.killAllChannelOutputs();\r\n  this.killAllChannelListeners();\r\n};\r\n\r\nAGClientSocket.prototype.killChannelOutputConsumer = function (consumerId) {\r\n  this._channelDataDemux.killConsumer(consumerId);\r\n};\r\n\r\nAGClientSocket.prototype.killChannelListenerConsumer = function (consumerId) {\r\n  this._channelEventDemux.killConsumer(consumerId);\r\n};\r\n\r\nAGClientSocket.prototype.getChannelOutputConsumerStats = function (consumerId) {\r\n  return this._channelDataDemux.getConsumerStats(consumerId);\r\n};\r\n\r\nAGClientSocket.prototype.getChannelListenerConsumerStats = function (consumerId) {\r\n  return this._channelEventDemux.getConsumerStats(consumerId);\r\n};\r\n\r\nAGClientSocket.prototype.getAllChannelOutputsConsumerStatsList = function () {\r\n  return this._channelDataDemux.getConsumerStatsListAll();\r\n};\r\n\r\nAGClientSocket.prototype.getAllChannelListenersConsumerStatsList = function () {\r\n  return this._channelEventDemux.getConsumerStatsListAll();\r\n};\r\n\r\nAGClientSocket.prototype.getChannelBackpressure = function (channelName) {\r\n  return Math.max(\r\n    this.channelGetOutputBackpressure(channelName),\r\n    this.channelGetAllListenersBackpressure(channelName)\r\n  );\r\n};\r\n\r\nAGClientSocket.prototype.getAllChannelOutputsBackpressure = function () {\r\n  return this._channelDataDemux.getBackpressureAll();\r\n};\r\n\r\nAGClientSocket.prototype.getAllChannelListenersBackpressure = function () {\r\n  return this._channelEventDemux.getBackpressureAll();\r\n};\r\n\r\nAGClientSocket.prototype.getAllChannelsBackpressure = function () {\r\n  return Math.max(\r\n    this.getAllChannelOutputsBackpressure(),\r\n    this.getAllChannelListenersBackpressure()\r\n  );\r\n};\r\n\r\nAGClientSocket.prototype.getChannelListenerConsumerBackpressure = function (consumerId) {\r\n  return this._channelEventDemux.getConsumerBackpressure(consumerId);\r\n};\r\n\r\nAGClientSocket.prototype.getChannelOutputConsumerBackpressure = function (consumerId) {\r\n  return this._channelDataDemux.getConsumerBackpressure(consumerId);\r\n};\r\n\r\nAGClientSocket.prototype.hasAnyChannelOutputConsumer = function (consumerId) {\r\n  return this._channelDataDemux.hasConsumerAll(consumerId);\r\n};\r\n\r\nAGClientSocket.prototype.hasAnyChannelListenerConsumer = function (consumerId) {\r\n  return this._channelEventDemux.hasConsumerAll(consumerId);\r\n};\r\n\r\nAGClientSocket.prototype.getChannelState = function (channelName) {\r\n  let channel = this._channelMap[channelName];\r\n  if (channel) {\r\n    return channel.state;\r\n  }\r\n  return AGChannel.UNSUBSCRIBED;\r\n};\r\n\r\nAGClientSocket.prototype.getChannelOptions = function (channelName) {\r\n  let channel = this._channelMap[channelName];\r\n  if (channel) {\r\n    return {...channel.options};\r\n  }\r\n  return {};\r\n};\r\n\r\nAGClientSocket.prototype._getAllChannelStreamNames = function (channelName) {\r\n  let streamNamesLookup = this._channelEventDemux.getConsumerStatsListAll()\r\n  .filter((stats) => {\r\n    return stats.stream.indexOf(`${channelName}/`) === 0;\r\n  })\r\n  .reduce((accumulator, stats) => {\r\n    accumulator[stats.stream] = true;\r\n    return accumulator;\r\n  }, {});\r\n  return Object.keys(streamNamesLookup);\r\n};\r\n\r\nAGClientSocket.prototype.channelCloseOutput = function (channelName) {\r\n  this._channelDataDemux.close(channelName);\r\n};\r\n\r\nAGClientSocket.prototype.channelCloseListener = function (channelName, eventName) {\r\n  this._channelEventDemux.close(`${channelName}/${eventName}`);\r\n};\r\n\r\nAGClientSocket.prototype.channelCloseAllListeners = function (channelName) {\r\n  let listenerStreams = this._getAllChannelStreamNames(channelName)\r\n  .forEach((streamName) => {\r\n    this._channelEventDemux.close(streamName);\r\n  });\r\n};\r\n\r\nAGClientSocket.prototype.channelKillOutput = function (channelName) {\r\n  this._channelDataDemux.kill(channelName);\r\n};\r\n\r\nAGClientSocket.prototype.channelKillListener = function (channelName, eventName) {\r\n  this._channelEventDemux.kill(`${channelName}/${eventName}`);\r\n};\r\n\r\nAGClientSocket.prototype.channelKillAllListeners = function (channelName) {\r\n  let listenerStreams = this._getAllChannelStreamNames(channelName)\r\n  .forEach((streamName) => {\r\n    this._channelEventDemux.kill(streamName);\r\n  });\r\n};\r\n\r\nAGClientSocket.prototype.channelGetOutputConsumerStatsList = function (channelName) {\r\n  return this._channelDataDemux.getConsumerStatsList(channelName);\r\n};\r\n\r\nAGClientSocket.prototype.channelGetListenerConsumerStatsList = function (channelName, eventName) {\r\n  return this._channelEventDemux.getConsumerStatsList(`${channelName}/${eventName}`);\r\n};\r\n\r\nAGClientSocket.prototype.channelGetAllListenersConsumerStatsList = function (channelName) {\r\n  return this._getAllChannelStreamNames(channelName)\r\n  .map((streamName) => {\r\n    return this._channelEventDemux.getConsumerStatsList(streamName);\r\n  })\r\n  .reduce((accumulator, statsList) => {\r\n    statsList.forEach((stats) => {\r\n      accumulator.push(stats);\r\n    });\r\n    return accumulator;\r\n  }, []);\r\n};\r\n\r\nAGClientSocket.prototype.channelGetOutputBackpressure = function (channelName) {\r\n  return this._channelDataDemux.getBackpressure(channelName);\r\n};\r\n\r\nAGClientSocket.prototype.channelGetListenerBackpressure = function (channelName, eventName) {\r\n  return this._channelEventDemux.getBackpressure(`${channelName}/${eventName}`);\r\n};\r\n\r\nAGClientSocket.prototype.channelGetAllListenersBackpressure = function (channelName) {\r\n  let listenerStreamBackpressures = this._getAllChannelStreamNames(channelName)\r\n  .map((streamName) => {\r\n    return this._channelEventDemux.getBackpressure(streamName);\r\n  });\r\n  return Math.max(...listenerStreamBackpressures.concat(0));\r\n};\r\n\r\nAGClientSocket.prototype.channelHasOutputConsumer = function (channelName, consumerId) {\r\n  return this._channelDataDemux.hasConsumer(channelName, consumerId);\r\n};\r\n\r\nAGClientSocket.prototype.channelHasListenerConsumer = function (channelName, eventName, consumerId) {\r\n  return this._channelEventDemux.hasConsumer(`${channelName}/${eventName}`, consumerId);\r\n};\r\n\r\nAGClientSocket.prototype.channelHasAnyListenerConsumer = function (channelName, consumerId) {\r\n  return this._getAllChannelStreamNames(channelName)\r\n  .some((streamName) => {\r\n    return this._channelEventDemux.hasConsumer(streamName, consumerId);\r\n  });\r\n};\r\n\r\nAGClientSocket.prototype.subscriptions = function (includePending) {\r\n  let subs = [];\r\n  Object.keys(this._channelMap).forEach((channelName) => {\r\n    if (includePending || this._channelMap[channelName].state === AGChannel.SUBSCRIBED) {\r\n      subs.push(channelName);\r\n    }\r\n  });\r\n  return subs;\r\n};\r\n\r\nAGClientSocket.prototype.isSubscribed = function (channelName, includePending) {\r\n  let channel = this._channelMap[channelName];\r\n  if (includePending) {\r\n    return !!channel;\r\n  }\r\n  return !!channel && channel.state === AGChannel.SUBSCRIBED;\r\n};\r\n\r\nAGClientSocket.prototype.processPendingSubscriptions = function () {\r\n  this.preparingPendingSubscriptions = false;\r\n  let pendingChannels = [];\r\n\r\n  Object.keys(this._channelMap).forEach((channelName) => {\r\n    let channel = this._channelMap[channelName];\r\n    if (channel.state === AGChannel.PENDING) {\r\n      pendingChannels.push(channel);\r\n    }\r\n  });\r\n\r\n  pendingChannels.sort((a, b) => {\r\n    let ap = a.options.priority || 0;\r\n    let bp = b.options.priority || 0;\r\n    if (ap > bp) {\r\n      return -1;\r\n    }\r\n    if (ap < bp) {\r\n      return 1;\r\n    }\r\n    return 0;\r\n  });\r\n\r\n  pendingChannels.forEach((channel) => {\r\n    this._trySubscribe(channel);\r\n  });\r\n};\r\n\r\nmodule.exports = AGClientSocket;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}